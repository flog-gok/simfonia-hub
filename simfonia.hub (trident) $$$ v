-- === Глобальные переменные ===
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/Library.lua"))()

-- Сервисы
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Lighting = game:GetService("Lighting")
local defaultFOV = Camera.FieldOfView
local Ignore = Workspace:WaitForChild("Ignore")
local FPSArms = Ignore:WaitForChild("FPSArms")

-- Список частей для проверки моделей (для ESP и Skeleton)
local requiredParts = {
    "Armor", "LeftFoot", "LeftHand", "LeftLowerArm", "LeftUpperArm", "LeftUpperLeg",
    "RightFoot", "RightHand", "RightLowerArm", "RightUpperArm", "RightUpperLeg",
    "Torso", "Head", "HumanoidRootPart", "LowerTorso", "AnimationController",
    "UpperTorso", "Chest", "LeftArm", "RightArm", "LeftLeg", "RightLeg"
}

-- === Состояния ===
-- Настройки ESP
local espSettings = {
    Enabled = false,
    Thickness = 2,
    ShowDistance = true,
    ShowHP = false,
    ShowEquippedTool = false,
    MaxDistance = 1000
}

-- Настройки Skeleton ESP
local skeletonSettings = {
    Enabled = false,
    Transparency = 0, -- Начальная прозрачность линий (0 - полностью видимые, 1 - полностью прозрачные)
    MaxDistance = 1000 -- Используем ту же дистанцию, что и для ESP
}


-- Обновляем hitboxSettings (заменяем старую реализацию)
local hitboxSettings = {
    HitboxExpandEnabled = false,
    HitboxSize = 1, -- Размер хитбокса головы в studs (от 1 до 10)
    BodyExpandEnabled = false,
    BodySize = 1, -- Размер тела (от 1 до 10)
    CanCollide = true, -- Коллизия головы (по умолчанию включена)
    Transparency = 0, -- Прозрачность головы (от 0 до 1)
    Variation = 0.1 -- Амплитуда случайного колебания размеров (для маскировки)
}

-- Настройки View Model
local VisualState = {
    ViewModelEnabled = false,
    FOV = 70
}

-- Добавляем состояние для No Shadows (добавляем после FullbrightState)
local ShadowsState = {
    Enabled = false,
    OriginalShadows = Lighting.GlobalShadows -- Сохраняем исходное состояние теней
}

-- Добавляем состояния для No Fog, Fullbright и No Grass
local FogState = {
    Enabled = false,
    OriginalFogStart = Lighting.FogStart, -- Сохраняем исходные настройки тумана
    OriginalFogEnd = Lighting.FogEnd,
    OriginalFogColor = Lighting.FogColor
}

local FullbrightState = {
    Enabled = false,
    OriginalBrightness = Lighting.Brightness, -- Сохраняем исходную яркость
    OriginalClockTime = Lighting.ClockTime -- Сохраняем исходное время суток
}

-- Добавляем состояние для Custom Arm (добавляем после ShadowsState)
local CustomArmState = {
    Enabled = false,
    Material = "None", -- По умолчанию None
    Color = Color3.fromRGB(255, 255, 255) -- Белый по умолчанию
}

-- Список доступных материалов
local availableMaterials = {
    "Neon",
    "Plastic",
    "None",
    "Stone",
    "Magma",
    "Air"
}

-- Список доступных цветов
local availableColors = {
    {Name = "White", Color = Color3.fromRGB(255, 255, 255)},
    {Name = "Red", Color = Color3.fromRGB(255, 0, 0)},
    {Name = "Green", Color = Color3.fromRGB(0, 255, 0)},
    {Name = "Blue", Color = Color3.fromRGB(0, 0, 255)},
    {Name = "Yellow", Color = Color3.fromRGB(255, 255, 0)},
    {Name = "Cyan", Color = Color3.fromRGB(0, 255, 255)},
    {Name = "Magenta", Color = Color3.fromRGB(255, 0, 255)},
    {Name = "Orange", Color = Color3.fromRGB(255, 165, 0)},
    {Name = "Purple", Color = Color3.fromRGB(128, 0, 128)},
    {Name = "Black", Color = Color3.fromRGB(0, 0, 0)}
}

-- Состояние для Crosshair
local CrosshairState = {
    Enabled = false,
    Style = "Cross", -- Стиль прицела по умолчанию
    Size = 10, -- Размер прицела (от 5 до 50)
    Thickness = 2, -- Толщина линий (от 1 до 10)
    Transparency = 0, -- Прозрачность (от 0 до 1)
    Color = Color3.fromRGB(255, 255, 255), -- Цвет по умолчанию (белый)
    RGBEnabled = false, -- Включён ли RGB-режим
    SpinEnabled = false, -- Включено ли вращение
    SpinSpeed = 1 -- Скорость вращения (от 0.1 до 5)
}

-- Доступные стили прицела
local crosshairStyles = {
    "Cross", -- Крест
    "Dot", -- Точка
    "Circle", -- Круг
    "Square", -- Квадрат
    "Triangle", -- Треугольник
    "X", -- Буква X
    "Diamond", -- Ромб
    "Star", -- Звезда
    "Plus", -- Плюс
    "Arrow" -- Стрелка
}

-- Доступные цвета
local crosshairColors = {
    {Name = "White", Color = Color3.fromRGB(255, 255, 255)},
    {Name = "Red", Color = Color3.fromRGB(255, 0, 0)},
    {Name = "Green", Color = Color3.fromRGB(0, 255, 0)},
    {Name = "Blue", Color = Color3.fromRGB(0, 0, 255)},
    {Name = "Yellow", Color = Color3.fromRGB(255, 255, 0)},
    {Name = "Cyan", Color = Color3.fromRGB(0, 255, 255)},
    {Name = "Magenta", Color = Color3.fromRGB(255, 0, 255)},
    {Name = "Orange", Color = Color3.fromRGB(255, 165, 0)},
    {Name = "Purple", Color = Color3.fromRGB(128, 0, 128)},
    {Name = "Black", Color = Color3.fromRGB(0, 0, 0)}
}

-- === UI ===
-- Создаём окно
local Window = Library:CreateWindow({
    Title = "simfonia hub (trident) v1.2",
    Center = true,
    AutoShow = true,
})

-- Создаём вкладки
local Tabs = {
    Legit = Window:AddTab("Legit"),
    Render = Window:AddTab("Render"),
    Misc = Window:AddTab("Misc"),
    Settings = Window:AddTab("Settings"),
}

-- ESP и Skeleton Settings (Render)
local RenderGroup = Tabs.Render:AddLeftGroupbox("ESP Settings")

local espEnabledToggle = RenderGroup:AddToggle("ESPEnabled", {
    Text = "Enable ESP",
    Default = false,
    Tooltip = "Включить/выключить ESP"
})
espEnabledToggle:OnChanged(function(value)
    espSettings.Enabled = value
end)

local espThicknessSlider = RenderGroup:AddSlider("ESPThickness", {
    Text = "Line Thickness",
    Default = 2,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Tooltip = "Установите толщину линий ESP"
})
espThicknessSlider:OnChanged(function(value)
    espSettings.Thickness = value
end)

local espShowDistanceToggle = RenderGroup:AddToggle("ESPShowDistance", {
    Text = "Show Distance",
    Default = true,
    Tooltip = "Показывать расстояние до объектов"
})
espShowDistanceToggle:OnChanged(function(value)
    espSettings.ShowDistance = value
end)

local espShowHPToggle = RenderGroup:AddToggle("ESPShowHP", {
    Text = "Show HP",
    Default = false,
    Tooltip = "Показывать здоровье персонажей"
})
espShowHPToggle:OnChanged(function(value)
    espSettings.ShowHP = value
end)

local espShowEquippedToolToggle = RenderGroup:AddToggle("ESPShowEquippedTool", {
    Text = "Show Equipped Tool",
    Default = false,
    Tooltip = "Показывать инструмент в руках"
})
espShowEquippedToolToggle:OnChanged(function(value)
    espSettings.ShowEquippedTool = value
end)

local espMaxDistanceSlider = RenderGroup:AddSlider("ESPMaxDistance", {
    Text = "Max Distance",
    Default = 1000,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    Tooltip = "Максимальная дистанция для отображения ESP и Skeleton (студс)"
})
espMaxDistanceSlider:OnChanged(function(value)
    espSettings.MaxDistance = value
    skeletonSettings.MaxDistance = value
end)

-- Skeleton Settings (в группе ESP)
local skeletonEnabledToggle = RenderGroup:AddToggle("SkeletonEnabled", {
    Text = "Enable Skeleton",
    Default = false,
    Tooltip = "Включить/выключить Skeleton ESP"
})
skeletonEnabledToggle:OnChanged(function(value)
    skeletonSettings.Enabled = value
end)

local skeletonTransparencySlider = RenderGroup:AddSlider("SkeletonTransparency", {
    Text = "Skeleton Transparency",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = "Установите прозрачность линий Skeleton (0 - полностью видимые, 1 - полностью прозрачные)"
})
skeletonTransparencySlider:OnChanged(function(value)
    skeletonSettings.Transparency = value
end)

-- Обновляем группу Hitbox Expander Settings в Legit (заменяем старую реализацию)
local LegitGroup = Tabs.Legit:AddLeftGroupbox("Hitbox Expander Settings")

-- Hitbox Expander (голова)
local hitboxExpandEnabledToggle = LegitGroup:AddToggle("HitboxExpandEnabled", {
    Text = "Enable Hitbox Expander",
    Default = false,
    Tooltip = "Включить/выключить расширение хитбокса головы"
})
hitboxExpandEnabledToggle:OnChanged(function(value)
    hitboxSettings.HitboxExpandEnabled = value
end)

local hitboxSizeSlider = LegitGroup:AddSlider("HitboxSize", {
    Text = "Head Hitbox Size",
    Default = 1,
    Min = 1,
    Max = 10, -- Уменьшаем максимальный размер
    Rounding = 0,
    Tooltip = "Размер хитбокса головы в studs (от 1 до 10)"
})
hitboxSizeSlider:OnChanged(function(value)
    hitboxSettings.HitboxSize = value
end)

-- Body Expander (тело)
local bodyExpandEnabledToggle = LegitGroup:AddToggle("BodyExpandEnabled", {
    Text = "Enable Body Expander",
    Default = false,
    Tooltip = "Включить/выключить расширение хитбокса тела"
})
bodyExpandEnabledToggle:OnChanged(function(value)
    hitboxSettings.BodyExpandEnabled = value
end)

local bodySizeSlider = LegitGroup:AddSlider("BodySize", {
    Text = "Body Hitbox Size",
    Default = 1,
    Min = 1,
    Max = 10, -- Уменьшаем максимальный размер
    Rounding = 0,
    Tooltip = "Размер хитбокса тела в studs (от 1 до 10)"
})
bodySizeSlider:OnChanged(function(value)
    hitboxSettings.BodySize = value
end)

-- Transparency (прозрачность головы)
local transparencySlider = LegitGroup:AddSlider("Transparency", {
    Text = "Head Transparency",
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = "Прозрачность головы (от 0 до 1)"
})
transparencySlider:OnChanged(function(value)
    hitboxSettings.Transparency = value
end)

-- Variation (случайное колебание размеров для маскировки)
local variationSlider = LegitGroup:AddSlider("Variation", {
    Text = "Size Variation",
    Default = 0.1,
    Min = 0,
    Max = 0.5,
    Rounding = 2,
    Tooltip = "Случайное колебание размеров для маскировки (от 0 до 0.5)"
})
variationSlider:OnChanged(function(value)
    hitboxSettings.Variation = value
end)

-- Полная секция UI для MiscGroup (заменяет старую реализацию)
local MiscGroup = Tabs.Misc:AddLeftGroupbox("Miscellaneous")

-- No Fog
local noFogToggle = MiscGroup:AddToggle("NoFogEnabled", {
    Text = "No Fog",
    Default = FogState.Enabled,
    Tooltip = "Убирает туман и другие атмосферные эффекты"
})
noFogToggle:OnChanged(function(value)
    FogState.Enabled = value
    Library:Notify("No Fog " .. (FogState.Enabled and "включён" or "выключен"))
end)

-- Fullbright
local fullbrightToggle = MiscGroup:AddToggle("FullbrightEnabled", {
    Text = "Fullbright",
    Default = FullbrightState.Enabled,
    Tooltip = "Делает всегда день (максимальная яркость)"
})
fullbrightToggle:OnChanged(function(value)
    FullbrightState.Enabled = value
    Library:Notify("Fullbright " .. (FullbrightState.Enabled and "включён" or "выключен"))
end)

-- No Shadows
local noShadowsToggle = MiscGroup:AddToggle("NoShadowsEnabled", {
    Text = "No Shadows",
    Default = ShadowsState.Enabled,
    Tooltip = "Убирает тени в игре"
})
noShadowsToggle:OnChanged(function(value)
    ShadowsState.Enabled = value
    Library:Notify("No Shadows " .. (ShadowsState.Enabled and "включён" or "выключен"))
end)

-- View Model
local viewModelEnabledToggle = MiscGroup:AddToggle("ViewModelEnabled", {
    Text = "Enable View Model",
    Default = VisualState.ViewModelEnabled,
    Tooltip = "Включает/выключает View Model"
})
viewModelEnabledToggle:OnChanged(function(value)
    VisualState.ViewModelEnabled = value
    Library:Notify("View Model " .. (VisualState.ViewModelEnabled and "включён" or "выключен"))
end)

local viewModelFOVSlider = MiscGroup:AddSlider("ViewModelFOV", {
    Text = "View Model FOV",
    Default = VisualState.FOV,
    Min = 70,
    Max = 120,
    Rounding = 0,
    Tooltip = "Настройка поля зрения для View Model (от 70 до 120)"
})
viewModelFOVSlider:OnChanged(function(value)
    VisualState.FOV = value
end)

-- Добавляем группу Extra Visuals в правую часть вкладки Misc
local ExtraVisualsGroup = Tabs.Misc:AddRightGroupbox("Extra Visuals")

-- Переключатель для включения/выключения Custom Arm
local customArmEnabledToggle = ExtraVisualsGroup:AddToggle("CustomArmEnabled", {
    Text = "Enable Custom Arm",
    Default = CustomArmState.Enabled,
    Tooltip = "Включить/выключить кастомизацию рук"
})
customArmEnabledToggle:OnChanged(function(value)
    CustomArmState.Enabled = value
    Library:Notify("Custom Arm " .. (CustomArmState.Enabled and "включён" or "выключен"))
end)

-- Выпадающий список для выбора материала
local materialSelection = ExtraVisualsGroup:AddDropdown("MaterialSelection", {
    Values = availableMaterials,
    Default = CustomArmState.Material,
    Text = "Arm Material",
    Tooltip = "Выберите материал для рук"
})
materialSelection:OnChanged(function(value)
    CustomArmState.Material = value
    Library:Notify("Материал рук изменён на: " .. value)
end)

-- Выпадающий список для выбора цвета
local colorSelection = ExtraVisualsGroup:AddDropdown("ColorSelection", {
    Values = {availableColors[1].Name, availableColors[2].Name, availableColors[3].Name, availableColors[4].Name, availableColors[5].Name, availableColors[6].Name, availableColors[7].Name, availableColors[8].Name, availableColors[9].Name, availableColors[10].Name},
    Default = availableColors[1].Name,
    Text = "Arm Color",
    Tooltip = "Выберите цвет для рук"
})
colorSelection:OnChanged(function(value)
    for _, colorData in pairs(availableColors) do
        if colorData.Name == value then
            CustomArmState.Color = colorData.Color
            Library:Notify("Цвет рук изменён на: " .. value)
            break
        end
    end
end)

-- Добавляем группу Crosshair в правую часть вкладки Misc
local CrosshairGroup = Tabs.Misc:AddRightGroupbox("Crosshair")

-- Переключатель для включения/выключения прицела
local crosshairEnabledToggle = CrosshairGroup:AddToggle("CrosshairEnabled", {
    Text = "Enable Crosshair",
    Default = CrosshairState.Enabled,
    Tooltip = "Включить/выключить кастомный прицел"
})
crosshairEnabledToggle:OnChanged(function(value)
    CrosshairState.Enabled = value
    Library:Notify("Crosshair " .. (CrosshairState.Enabled and "включён" or "выключен"))
end)

-- Выпадающий список для выбора стиля прицела
local crosshairStyleSelection = CrosshairGroup:AddDropdown("CrosshairStyleSelection", {
    Values = crosshairStyles,
    Default = CrosshairState.Style,
    Text = "Crosshair Style",
    Tooltip = "Выберите стиль прицела"
})
crosshairStyleSelection:OnChanged(function(value)
    CrosshairState.Style = value
    Library:Notify("Стиль прицела изменён на: " .. value)
end)

-- Слайдер для настройки размера прицела
local crosshairSizeSlider = CrosshairGroup:AddSlider("CrosshairSize", {
    Text = "Crosshair Size",
    Default = CrosshairState.Size,
    Min = 5,
    Max = 50,
    Rounding = 0,
    Tooltip = "Размер прицела (от 5 до 50)"
})
crosshairSizeSlider:OnChanged(function(value)
    CrosshairState.Size = value
end)

-- Слайдер для настройки толщины прицела
local crosshairThicknessSlider = CrosshairGroup:AddSlider("CrosshairThickness", {
    Text = "Crosshair Thickness",
    Default = CrosshairState.Thickness,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Tooltip = "Толщина линий прицела (от 1 до 10)"
})
crosshairThicknessSlider:OnChanged(function(value)
    CrosshairState.Thickness = value
end)

-- Слайдер для настройки прозрачности
local crosshairTransparencySlider = CrosshairGroup:AddSlider("CrosshairTransparency", {
    Text = "Crosshair Transparency",
    Default = CrosshairState.Transparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = "Прозрачность прицела (от 0 до 1)"
})
crosshairTransparencySlider:OnChanged(function(value)
    CrosshairState.Transparency = value
end)

-- Выпадающий список для выбора цвета
local crosshairColorSelection = CrosshairGroup:AddDropdown("CrosshairColorSelection", {
    Values = {crosshairColors[1].Name, crosshairColors[2].Name, crosshairColors[3].Name, crosshairColors[4].Name, crosshairColors[5].Name, crosshairColors[6].Name, crosshairColors[7].Name, crosshairColors[8].Name, crosshairColors[9].Name, crosshairColors[10].Name},
    Default = crosshairColors[1].Name,
    Text = "Crosshair Color",
    Tooltip = "Выберите цвет прицела"
})
crosshairColorSelection:OnChanged(function(value)
    if not CrosshairState.RGBEnabled then
        for _, colorData in pairs(crosshairColors) do
            if colorData.Name == value then
                CrosshairState.Color = colorData.Color
                Library:Notify("Цвет прицела изменён на: " .. value)
                break
            end
        end
    end
end)

-- Переключатель для RGB-режима
local crosshairRGBToggle = CrosshairGroup:AddToggle("CrosshairRGBEnabled", {
    Text = "RGB Crosshair",
    Default = CrosshairState.RGBEnabled,
    Tooltip = "Включить/выключить RGB-режим для прицела"
})
crosshairRGBToggle:OnChanged(function(value)
    CrosshairState.RGBEnabled = value
    Library:Notify("RGB-режим прицела " .. (CrosshairState.RGBEnabled and "включён" or "выключен"))
end)

-- Переключатель для вращения прицела
local crosshairSpinToggle = CrosshairGroup:AddToggle("CrosshairSpinEnabled", {
    Text = "Spin Crosshair",
    Default = CrosshairState.SpinEnabled,
    Tooltip = "Включить/выключить вращение прицела"
})
crosshairSpinToggle:OnChanged(function(value)
    CrosshairState.SpinEnabled = value
    Library:Notify("Вращение прицела " .. (CrosshairState.SpinEnabled and "включено" or "выключено"))
end)

-- Слайдер для скорости вращения
local crosshairSpinSpeedSlider = CrosshairGroup:AddSlider("CrosshairSpinSpeed", {
    Text = "Spin Speed",
    Default = CrosshairState.SpinSpeed,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Tooltip = "Скорость вращения прицела (от 0.1 до 5)"
})
crosshairSpinSpeedSlider:OnChanged(function(value)
    CrosshairState.SpinSpeed = value
end)

-- Settings
local SettingsGroup = Tabs.Settings:AddLeftGroupbox("Settings")

-- Уведомление о загрузке
Library:Notify("Скрипт загружен! Используйте вкладки для настройки.", 5)

-- === Функции логики ===
-- Функция проверки, является ли модель персонажем
local function hasRequiredParts(model)
    if not model then return false end
    -- Проверяем наличие HumanoidRootPart или любых BasePart
    if model:FindFirstChild("HumanoidRootPart") then
        return true
    end
    for _, child in ipairs(model:GetDescendants()) do
        if child:IsA("BasePart") then
            return true
        end
    end
    return false
end


-- Список частей для проверки моделей (для ESP)
local requiredParts = {
    "Armor", "LeftFoot", "LeftHand", "LeftLowerArm", "LeftUpperArm", "LeftUpperLeg",
    "RightFoot", "RightHand", "RightLowerArm", "RightUpperArm", "RightUpperLeg",
    "Torso", "Head", "HumanoidRootPart", "LowerTorso", "AnimationController",
    "UpperTorso", "Chest", "LeftArm", "RightArm", "LeftLeg", "RightLeg"
}

-- === ESP ===
local espObjects = {}

local function ESP()
    local function createESP(model)
        if espObjects[model] then return end

        local box = Drawing.new("Square")
        box.Thickness = espSettings.Thickness
        box.Color = Color3.fromRGB(255, 0, 0) -- По умолчанию красный
        box.Filled = false
        box.Transparency = 1

        local distText = Drawing.new("Text")
        distText.Size = 14
        distText.Color = Color3.fromRGB(255, 255, 0)
        distText.Outline = true
        distText.Center = true

        local hpText = Drawing.new("Text")
        hpText.Size = 14
        hpText.Color = Color3.fromRGB(0, 255, 0)
        hpText.Outline = true
        hpText.Center = true

        local toolText = Drawing.new("Text")
        toolText.Size = 14
        toolText.Color = Color3.fromRGB(255, 255, 0)
        toolText.Outline = true
        toolText.Center = true

        espObjects[model] = {
            Box = box,
            DistText = distText,
            HPText = hpText,
            ToolText = toolText
        }
    end

    local function removeESP(model)
        if espObjects[model] then
            espObjects[model].Box:Remove()
            espObjects[model].DistText:Remove()
            espObjects[model].HPText:Remove()
            espObjects[model].ToolText:Remove()
            espObjects[model] = nil
        end
    end

    local function isModelInView(model)
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if not hrp then return false end

        -- Проверка направления взгляда
        local cameraPos = Camera.CFrame.Position
        local cameraLookVector = Camera.CFrame.LookVector
        local modelPos = hrp.Position
        local directionToModel = (modelPos - cameraPos).Unit
        local dotProduct = directionToModel:Dot(cameraLookVector)
        if dotProduct <= 0.5 then return false end -- Модель вне поля зрения (угол > 60 градусов)

        -- Проверка на препятствия
        local rayOrigin = cameraPos
        local rayDirection = (modelPos - cameraPos).Unit * (modelPos - cameraPos).Magnitude
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {model, Camera} -- Игнорируем саму модель и камеру
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

        -- Если есть препятствие, модель не видна
        if raycastResult then return false end

        return true
    end

    local function updateESP()
        if not espSettings.Enabled then
            for _, esp in pairs(espObjects) do
                esp.Box.Visible = false
                esp.DistText.Visible = false
                esp.HPText.Visible = false
                esp.ToolText.Visible = false
            end
            return
        end

        for model, esp in pairs(espObjects) do
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if not hrp or not model.Parent or not hasRequiredParts(model) then
                removeESP(model)
            else
                local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                if distance > espSettings.MaxDistance then
                    esp.Box.Visible = false
                    esp.DistText.Visible = false
                    esp.HPText.Visible = false
                    esp.ToolText.Visible = false
                    continue
                end

                local orientation, size = model:GetBoundingBox()
                local pos, onScreen = Camera:WorldToViewportPoint(orientation.Position)
                if onScreen then
                    local corner1 = Camera:WorldToViewportPoint(orientation.Position + size / 2)
                    local corner2 = Camera:WorldToViewportPoint(orientation.Position - size / 2)
                    local screenSize = Vector2.new(math.abs(corner1.X - corner2.X), math.abs(corner1.Y - corner2.Y))

                    local isInView = isModelInView(model)
                    esp.Box.Color = isInView and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)

                    esp.Box.Size = screenSize
                    esp.Box.Position = Vector2.new(pos.X - screenSize.X / 2, pos.Y - screenSize.Y / 2)
                    esp.Box.Visible = true
                    esp.Box.Transparency = 1
                    esp.Box.Thickness = espSettings.Thickness

                    local textOffset = 15
                    if espSettings.ShowDistance then
                        esp.DistText.Text = math.floor(distance) .. " studs"
                        esp.DistText.Position = Vector2.new(pos.X, pos.Y + screenSize.Y / 2 + textOffset)
                        esp.DistText.Visible = true
                        textOffset = textOffset + 15
                    else
                        esp.DistText.Visible = false
                    end

                    if espSettings.ShowHP then
                        local humanoid = model:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            esp.HPText.Text = math.floor(humanoid.Health) .. "/" .. math.floor(humanoid.MaxHealth) .. " HP"
                            esp.HPText.Position = Vector2.new(pos.X, pos.Y + screenSize.Y / 2 + textOffset)
                            esp.HPText.Visible = true
                            textOffset = textOffset + 15
                        else
                            esp.HPText.Visible = false
                        end
                    else
                        esp.HPText.Visible = false
                    end

                    if espSettings.ShowEquippedTool then
                        local tool = model:FindFirstChildOfClass("Tool")
                        esp.ToolText.Text = tool and tool.Name or "None"
                        esp.ToolText.Position = Vector2.new(pos.X, pos.Y + screenSize.Y / 2 + textOffset)
                        esp.ToolText.Visible = true
                    else
                        esp.ToolText.Visible = false
                    end
                else
                    esp.Box.Visible = false
                    esp.DistText.Visible = false
                    esp.HPText.Visible = false
                    esp.ToolText.Visible = false
                end
            end
        end
    end

    local function checkModels()
        for _, model in pairs(workspace:GetDescendants()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and hasRequiredParts(model) then
                createESP(model)
            end
        end
    end

    RunService.RenderStepped:Connect(updateESP)

    workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") and descendant:FindFirstChild("HumanoidRootPart") and hasRequiredParts(descendant) then
            createESP(descendant)
        end
    end)

    workspace.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Model") then
            removeESP(descendant)
        end
    end)

    checkModels()
end

-- Инициализация ESP
ESP()

-- === Skeleton ESP ===
local skeletonObjects = {}

local function Skeleton()
    local function createSkeleton(model)
        if skeletonObjects[model] then return end

        -- Создаём таблицу для хранения линий
        local lines = {}

        -- Находим ключевые части тела
        local head = model:FindFirstChild("Head")
        local upperTorso = model:FindFirstChild("UpperTorso") or model:FindFirstChild("Torso")
        local lowerTorso = model:FindFirstChild("LowerTorso")
        local leftUpperArm = model:FindFirstChild("LeftUpperArm")
        local rightUpperArm = model:FindFirstChild("RightUpperArm")
        local leftUpperLeg = model:FindFirstChild("LeftUpperLeg")
        local rightUpperLeg = model:FindFirstChild("RightUpperLeg")

        -- Проверяем, есть ли голова как начальная точка
        if not head then return end

        -- Создаём линии для скелета
        local function createLine(fromPart, toPart)
            if fromPart and toPart then
                local line = Drawing.new("Line")
                line.Thickness = 1
                line.Color = Color3.fromRGB(255, 255, 255) -- Белый цвет линий
                line.Transparency = 1 - skeletonSettings.Transparency
                table.insert(lines, line)
            end
        end

        -- Соединяем части тела линиями
        createLine(head, upperTorso) -- Голова → Верхний торс
        if upperTorso then
            createLine(upperTorso, lowerTorso) -- Верхний торс → Нижний торс
            createLine(upperTorso, leftUpperArm) -- Верхний торс → Левая рука
            createLine(upperTorso, rightUpperArm) -- Верхний торс → Правая рука
        end
        if lowerTorso then
            createLine(lowerTorso, leftUpperLeg) -- Нижний торс → Левая нога
            createLine(lowerTorso, rightUpperLeg) -- Нижний торс → Правая нога
        end

        skeletonObjects[model] = { Lines = lines }
    end

    local function removeSkeleton(model)
        if skeletonObjects[model] then
            for _, line in pairs(skeletonObjects[model].Lines) do
                line:Remove()
            end
            skeletonObjects[model] = nil
        end
    end

    local function updateSkeleton()
        if not skeletonSettings.Enabled then
            for _, skeleton in pairs(skeletonObjects) do
                for _, line in pairs(skeleton.Lines) do
                    line.Visible = false
                end
            end
            return
        end

        for model, skeleton in pairs(skeletonObjects) do
            local hrp = model:FindFirstChild("HumanoidRootPart")
            if not hrp or not model.Parent or not hasRequiredParts(model) then
                removeSkeleton(model)
            else
                local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
                if distance > skeletonSettings.MaxDistance then
                    for _, line in pairs(skeleton.Lines) do
                        line.Visible = false
                    end
                else
                    -- Обновляем линии
                    local head = model:FindFirstChild("Head")
                    local upperTorso = model:FindFirstChild("UpperTorso") or model:FindFirstChild("Torso")
                    local lowerTorso = model:FindFirstChild("LowerTorso")
                    local leftUpperArm = model:FindFirstChild("LeftUpperArm")
                    local rightUpperArm = model:FindFirstChild("RightUpperArm")
                    local leftUpperLeg = model:FindFirstChild("LeftUpperLeg")
                    local rightUpperLeg = model:FindFirstChild("RightUpperLeg")

                    local lineIndex = 1
                    local function updateLine(fromPart, toPart)
                        if lineIndex > #skeleton.Lines then return end
                        local line = skeleton.Lines[lineIndex]
                        if fromPart and toPart then
                            local fromPos, fromVisible = Camera:WorldToViewportPoint(fromPart.Position)
                            local toPos, toVisible = Camera:WorldToViewportPoint(toPart.Position)
                            if fromVisible and toVisible then
                                line.From = Vector2.new(fromPos.X, fromPos.Y)
                                line.To = Vector2.new(toPos.X, toPos.Y)
                                line.Transparency = 1 - skeletonSettings.Transparency
                                line.Visible = true
                            else
                                line.Visible = false
                            end
                        else
                            line.Visible = false
                        end
                        lineIndex = lineIndex + 1
                    end

                    updateLine(head, upperTorso)
                    if upperTorso then
                        updateLine(upperTorso, lowerTorso)
                        updateLine(upperTorso, leftUpperArm)
                        updateLine(upperTorso, rightUpperArm)
                    end
                    if lowerTorso then
                        updateLine(lowerTorso, leftUpperLeg)
                        updateLine(lowerTorso, rightUpperLeg)
                    end
                end
            end
        end
    end

    local function checkModelsForSkeleton()
        for _, model in pairs(workspace:GetDescendants()) do
            if model:IsA("Model") and model:FindFirstChild("HumanoidRootPart") and hasRequiredParts(model) then
                createSkeleton(model)
            end
        end
    end

    RunService.RenderStepped:Connect(updateSkeleton)

    workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") and descendant:FindFirstChild("HumanoidRootPart") and hasRequiredParts(descendant) then
            createSkeleton(descendant)
        end
    end)

    workspace.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Model") then
            removeSkeleton(descendant)
        end
    end)

    checkModelsForSkeleton()
end

-- Инициализация Skeleton
Skeleton()

-- Обновляем HitboxExpander (заменяем старую реализацию)
local originalHeadSizes = {} -- Храним оригинальные размеры головы
local originalBodySizes = {} -- Храним оригинальные размеры тела
local originalHeadProperties = {} -- Храним оригинальные свойства головы (CanCollide, Transparency)

local function HitboxExpander()
    local function expandHitbox(model)
        -- Голова
        local head = model:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            -- Сохраняем оригинальные свойства головы, если ещё не сохранены
            if not originalHeadProperties[model] then
                originalHeadProperties[model] = {
                    CanCollide = head.CanCollide,
                    Transparency = head.Transparency
                }
            end
            -- Сохраняем оригинальный размер головы
            if not originalHeadSizes[model] then
                originalHeadSizes[model] = head.Size
            end
            -- Изменяем размер головы, если Hitbox Expander включён
            if hitboxSettings.HitboxExpandEnabled then
                local newSize = hitboxSettings.HitboxSize
                head.Size = Vector3.new(newSize, newSize, newSize)
            else
                head.Size = originalHeadSizes[model]
            end
            -- Применяем настройки коллизии и прозрачности
            head.CanCollide = hitboxSettings.CanCollide
            head.Transparency = hitboxSettings.Transparency
            head.CFrame = head.CFrame -- Сохраняем позицию
        end

        -- Тело (UpperTorso и LowerTorso)
        local bodyParts = {
            model:FindFirstChild("UpperTorso"),
            model:FindFirstChild("LowerTorso")
        }
        for _, part in pairs(bodyParts) do
            if part and part:IsA("BasePart") then
                -- Сохраняем оригинальный размер тела
                if not originalBodySizes[part] then
                    originalBodySizes[part] = part.Size
                end
                -- Изменяем размер тела, если Body Expander включён
                if hitboxSettings.BodyExpandEnabled then
                    local newSize = hitboxSettings.BodySize
                    part.Size = Vector3.new(newSize, newSize, newSize)
                else
                    part.Size = originalBodySizes[part]
                end
                part.CFrame = part.CFrame -- Сохраняем позицию
            end
        end
    end

    local function restoreHitbox(model)
        -- Восстанавливаем голову
        if originalHeadSizes[model] then
            local head = model:FindFirstChild("Head")
            if head then
                head.Size = originalHeadSizes[model]
                head.CFrame = head.CFrame
                -- Восстанавливаем оригинальные свойства
                if originalHeadProperties[model] then
                    head.CanCollide = originalHeadProperties[model].CanCollide
                    head.Transparency = originalHeadProperties[model].Transparency
                end
            end
            originalHeadSizes[model] = nil
            originalHeadProperties[model] = nil
        end
        -- Восстанавливаем тело
        local bodyParts = {
            model:FindFirstChild("UpperTorso"),
            model:FindFirstChild("LowerTorso")
        }
        for _, part in pairs(bodyParts) do
            if part and originalBodySizes[part] then
                part.Size = originalBodySizes[part]
                part.CFrame = part.CFrame
                originalBodySizes[part] = nil
            end
        end
    end

    local function checkModelsForHitbox()
        for _, model in pairs(Workspace:GetDescendants()) do
            if model:IsA("Model") and model ~= LocalPlayer.Character and model:FindFirstChild("HumanoidRootPart") and hasRequiredParts(model) then
                expandHitbox(model)
            end
        end
    end

    Workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") and descendant ~= LocalPlayer.Character and descendant:FindFirstChild("HumanoidRootPart") and hasRequiredParts(descendant) then
            expandHitbox(descendant)
        end
    end)

    Workspace.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Model") then
            restoreHitbox(descendant)
        end
    end)

    checkModelsForHitbox()

    RunService.RenderStepped:Connect(function()
        checkModelsForHitbox()
    end)
end

HitboxExpander()

-- === View Model ===
local function updateViewModel()
    if VisualState.ViewModelEnabled then
        Camera.FieldOfView = VisualState.FOV
    else
        Camera.FieldOfView = defaultFOV
    end
end

-- Обновляем цикл RenderStepped
RunService.RenderStepped:Connect(function(deltaTime)
    updateViewModel()
end)

-- Обновляем цикл RenderStepped (заменяем старую реализацию)
RunService.RenderStepped:Connect(function(deltaTime)
    -- No Fog
    if FogState.Enabled then
        Lighting.FogStart = 100000
        Lighting.FogEnd = 100000
        Lighting.FogColor = Color3.new(1, 1, 1) -- Белый цвет, чтобы убрать эффект
    else
        Lighting.FogStart = FogState.OriginalFogStart
        Lighting.FogEnd = FogState.OriginalFogEnd
        Lighting.FogColor = FogState.OriginalFogColor
    end

    -- Fullbright
    if FullbrightState.Enabled then
        Lighting.Brightness = 3 -- Максимальная яркость
        Lighting.ClockTime = 12 -- Полдень
    else
        Lighting.Brightness = FullbrightState.OriginalBrightness
        Lighting.ClockTime = FullbrightState.OriginalClockTime
    end

    -- No Shadows
    if ShadowsState.Enabled then
        Lighting.GlobalShadows = false -- Отключаем тени
    else
        Lighting.GlobalShadows = ShadowsState.OriginalShadows -- Восстанавливаем исходное состояние
    end

    -- View Model (уже есть, оставляем без изменений)
    if VisualState.ViewModelEnabled then
        Camera.FieldOfView = VisualState.FOV
    else
        Camera.FieldOfView = defaultFOV
    end
end)

-- Оптимизированная логика HitboxExpander
local originalHeadSizes = {}
local originalBodySizes = {}
local originalHeadProperties = {}
local trackedModels = {} -- Кэшируем модели, которые нужно обрабатывать

local function HitboxExpander()
    local function applyHitboxChanges(model)
        -- Пропускаем локального игрока
        if model == LocalPlayer.Character then return end

        -- Голова
        local head = model:FindFirstChild("Head")
        if head and head:IsA("BasePart") then
            -- Сохраняем оригинальные свойства
            if not originalHeadProperties[model] then
                originalHeadProperties[model] = {
                    CanCollide = head.CanCollide,
                    Transparency = head.Transparency
                }
            end
            if not originalHeadSizes[model] then
                originalHeadSizes[model] = head.Size
            end
            -- Изменяем размер головы
            if hitboxSettings.HitboxExpandEnabled then
                local baseSize = hitboxSettings.HitboxSize
                local variation = hitboxSettings.Variation * (math.random() - 0.5) * 2
                local newSize = math.clamp(baseSize + variation, 1, 10)
                local targetSize = Vector3.new(newSize, newSize, newSize)
                if head.Size ~= targetSize then -- Проверяем, нужно ли обновлять
                    head.Size = targetSize
                    head.CFrame = head.CFrame
                end
            else
                local originalSize = originalHeadSizes[model] or Vector3.new(2, 1, 1)
                if head.Size ~= originalSize then
                    head.Size = originalSize
                    head.CFrame = head.CFrame
                end
            end
            -- Применяем прозрачность (будет обновляться через Heartbeat)
            head.CanCollide = true -- Оставляем коллизию включённой
        end

        -- Тело (UpperTorso и LowerTorso)
        local bodyParts = {
            UpperTorso = model:FindFirstChild("UpperTorso"),
            LowerTorso = model:FindFirstChild("LowerTorso")
        }
        for partName, part in pairs(bodyParts) do
            if part and part:IsA("BasePart") then
                local key = tostring(model) .. "_" .. partName
                if not originalBodySizes[key] then
                    originalBodySizes[key] = part.Size
                end
                if hitboxSettings.BodyExpandEnabled then
                    local baseSize = hitboxSettings.BodySize
                    local variation = hitboxSettings.Variation * (math.random() - 0.5) * 2
                    local newSize = math.clamp(baseSize + variation, 1, 10)
                    local targetSize = Vector3.new(newSize, newSize, newSize)
                    if part.Size ~= targetSize then
                        part.Size = targetSize
                        part.CFrame = part.CFrame
                    end
                else
                    local originalSize = originalBodySizes[key] or Vector3.new(4, 2, 1)
                    if part.Size ~= originalSize then
                        part.Size = originalSize
                        part.CFrame = part.CFrame
                    end
                end
            end
        end
    end

    local function restoreHitbox(model)
        if originalHeadSizes[model] then
            local head = model:FindFirstChild("Head")
            if head then
                head.Size = originalHeadSizes[model] or Vector3.new(2, 1, 1)
                head.CFrame = head.CFrame
                if originalHeadProperties[model] then
                    head.CanCollide = originalHeadProperties[model].CanCollide
                    head.Transparency = originalHeadProperties[model].Transparency
                end
            end
            originalHeadSizes[model] = nil
            originalHeadProperties[model] = nil
        end
        local bodyParts = {
            UpperTorso = model:FindFirstChild("UpperTorso"),
            LowerTorso = model:FindFirstChild("LowerTorso")
        }
        for partName, part in pairs(bodyParts) do
            if part then
                local key = tostring(model) .. "_" .. partName
                if originalBodySizes[key] then
                    part.Size = originalBodySizes[key] or Vector3.new(4, 2, 1)
                    part.CFrame = part.CFrame
                    originalBodySizes[key] = nil
                end
            end
        end
        trackedModels[model] = nil -- Удаляем из отслеживаемых моделей
    end

    local function updateTransparency()
        for model, _ in pairs(trackedModels) do
            local head = model:FindFirstChild("Head")
            if head and head:IsA("BasePart") then
                local currentTransparency = head.Transparency
                local targetTransparency = hitboxSettings.Transparency
                if math.abs(currentTransparency - targetTransparency) > 0.01 then
                    head.Transparency = currentTransparency + (targetTransparency - currentTransparency) * 0.1
                end
            end
        end
    end

    local function checkModelsForHitbox()
        for _, model in pairs(Workspace:GetDescendants()) do
            if model:IsA("Model") and model ~= LocalPlayer.Character and model:FindFirstChild("HumanoidRootPart") and hasRequiredParts(model) then
                if not trackedModels[model] then
                    trackedModels[model] = true
                    applyHitboxChanges(model)
                end
            end
        end
    end

    -- Инициализация: проверяем существующие модели
    checkModelsForHitbox()

    -- Обновляем при добавлении новых моделей
    Workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Model") and descendant ~= LocalPlayer.Character and descendant:FindFirstChild("HumanoidRootPart") and hasRequiredParts(descendant) then
            trackedModels[descendant] = true
            applyHitboxChanges(descendant)
        end
    end)

    -- Восстанавливаем при удалении моделей
    Workspace.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("Model") then
            restoreHitbox(descendant)
        end
    end)

    -- Обновляем размеры при изменении настроек
    local function onSettingsChanged()
        for model, _ in pairs(trackedModels) do
            applyHitboxChanges(model)
        end
    end

    -- Подписываемся на изменения настроек
    hitboxExpandEnabledToggle:OnChanged(function(value)
        hitboxSettings.HitboxExpandEnabled = value
        onSettingsChanged()
    end)
    hitboxSizeSlider:OnChanged(function(value)
        hitboxSettings.HitboxSize = value
        onSettingsChanged()
    end)
    bodyExpandEnabledToggle:OnChanged(function(value)
        hitboxSettings.BodyExpandEnabled = value
        onSettingsChanged()
    end)
    bodySizeSlider:OnChanged(function(value)
        hitboxSettings.BodySize = value
        onSettingsChanged()
    end)
    variationSlider:OnChanged(function(value)
        hitboxSettings.Variation = value
        onSettingsChanged()
    end)

    -- Обновляем прозрачность через Heartbeat (реже, чем RenderStepped)
    RunService.Heartbeat:Connect(updateTransparency)
end

HitboxExpander()

-- Список частей рук
local armParts = {
    "LeftHand",
    "LeftLowerArm",
    "LeftUpperArm",
    "RightHand",
    "RightLowerArm",
    "RightUpperArm"
}

-- Храним оригинальные свойства для всех частей рук
local originalArmProperties = {}
for _, partName in pairs(armParts) do
    originalArmProperties[partName] = {
        Material = nil,
        Color = nil,
        Transparency = nil
    }
end

local function CustomArm()
    -- Проверяем наличие всех частей рук
    local parts = {}
    for _, partName in pairs(armParts) do
        local part = FPSArms:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            parts[partName] = part
        end
    end

    -- Если не найдены все части, выходим
    if not next(parts) then return end

    -- Сохраняем оригинальные свойства, если ещё не сохранены
    for partName, part in pairs(parts) do
        if not originalArmProperties[partName].Material then
            originalArmProperties[partName].Material = part.Material
            originalArmProperties[partName].Color = part.Color
            originalArmProperties[partName].Transparency = part.Transparency
        end
    end

    -- Применяем изменения каждый кадр через RunService.RenderStepped
    RunService.RenderStepped:Connect(function()
        if CustomArmState.Enabled then
            -- Применяем материал и прозрачность
            if CustomArmState.Material == "Air" then
                for _, part in pairs(parts) do
                    part.Transparency = 1
                end
            else
                for partName, part in pairs(parts) do
                    part.Transparency = originalArmProperties[partName].Transparency
                    part.Material = Enum.Material[CustomArmState.Material]
                end
            end

            -- Применяем цвет (если материал не Air)
            if CustomArmState.Material ~= "Air" then
                for _, part in pairs(parts) do
                    part.Color = CustomArmState.Color
                end
            end
        else
            -- Восстанавливаем оригинальные свойства
            for partName, part in pairs(parts) do
                part.Material = originalArmProperties[partName].Material
                part.Color = originalArmProperties[partName].Color
                part.Transparency = originalArmProperties[partName].Transparency
            end
        end
    end)

    -- Следим за изменениями FPSArms (на случай, если модель будет удалена и создана заново)
    FPSArms.AncestryChanged:Connect(function()
        if not FPSArms.Parent then
            -- Если FPSArms удалён, очищаем оригинальные свойства
            for partName in pairs(originalArmProperties) do
                originalArmProperties[partName].Material = nil
                originalArmProperties[partName].Color = nil
                originalArmProperties[partName].Transparency = nil
            end
        end
    end)
end

-- Инициализация Custom Arm
CustomArm()

-- Объекты Drawing для прицела
local crosshairObjects = {}

local function Crosshair()
    -- Функция для очистки текущего прицела
    local function clearCrosshair()
        for _, obj in pairs(crosshairObjects) do
            if obj.Destroy then
                obj:Destroy() -- Используем Destroy вместо Remove
            elseif obj.Remove then
                obj:Remove() -- Для совместимости с версиями, где есть Remove
            else
                -- Если ни Destroy, ни Remove не поддерживаются, скрываем объект
                if obj.Visible ~= nil then
                    obj.Visible = false
                end
            end
        end
        crosshairObjects = {}
    end

    -- Функция для создания прицела в зависимости от стиля
    local function createCrosshair()
        clearCrosshair()

        local centerX, centerY = workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2
        local size = CrosshairState.Size
        local thickness = CrosshairState.Thickness
        local transparency = CrosshairState.Transparency

        if CrosshairState.Style == "Cross" then
            -- Горизонтальная линия
            local hLine = Drawing.new("Line")
            hLine.From = Vector2.new(centerX - size, centerY)
            hLine.To = Vector2.new(centerX + size, centerY)
            hLine.Thickness = thickness
            hLine.Transparency = 1 - transparency
            table.insert(crosshairObjects, hLine)

            -- Вертикальная линия
            local vLine = Drawing.new("Line")
            vLine.From = Vector2.new(centerX, centerY - size)
            vLine.To = Vector2.new(centerX, centerY + size)
            vLine.Thickness = thickness
            vLine.Transparency = 1 - transparency
            table.insert(crosshairObjects, vLine)

        elseif CrosshairState.Style == "Dot" then
            local dot = Drawing.new("Circle")
            dot.Position = Vector2.new(centerX, centerY)
            dot.Radius = size / 4
            dot.Filled = true
            dot.Thickness = thickness
            dot.Transparency = 1 - transparency
            table.insert(crosshairObjects, dot)

        elseif CrosshairState.Style == "Circle" then
            local circle = Drawing.new("Circle")
            circle.Position = Vector2.new(centerX, centerY)
            circle.Radius = size / 2
            circle.Filled = false
            circle.Thickness = thickness
            circle.Transparency = 1 - transparency
            table.insert(crosshairObjects, circle)

        elseif CrosshairState.Style == "Square" then
            local square = Drawing.new("Square")
            square.Position = Vector2.new(centerX - size / 2, centerY - size / 2)
            square.Size = Vector2.new(size, size)
            square.Filled = false
            square.Thickness = thickness
            square.Transparency = 1 - transparency
            table.insert(crosshairObjects, square)

        elseif CrosshairState.Style == "Triangle" then
            local triangle = Drawing.new("Triangle")
            triangle.PointA = Vector2.new(centerX, centerY - size / 2)
            triangle.PointB = Vector2.new(centerX - size / 2, centerY + size / 2)
            triangle.PointC = Vector2.new(centerX + size / 2, centerY + size / 2)
            triangle.Filled = false
            triangle.Thickness = thickness
            triangle.Transparency = 1 - transparency
            table.insert(crosshairObjects, triangle)

        elseif CrosshairState.Style == "X" then
            -- Диагональная линия 1
            local diag1 = Drawing.new("Line")
            diag1.From = Vector2.new(centerX - size / 2, centerY - size / 2)
            diag1.To = Vector2.new(centerX + size / 2, centerY + size / 2)
            diag1.Thickness = thickness
            diag1.Transparency = 1 - transparency
            table.insert(crosshairObjects, diag1)

            -- Диагональная линия 2
            local diag2 = Drawing.new("Line")
            diag2.From = Vector2.new(centerX + size / 2, centerY - size / 2)
            diag2.To = Vector2.new(centerX - size / 2, centerY + size / 2)
            diag2.Thickness = thickness
            diag2.Transparency = 1 - transparency
            table.insert(crosshairObjects, diag2)

        elseif CrosshairState.Style == "Diamond" then
            local diamond = Drawing.new("Quad")
            diamond.PointA = Vector2.new(centerX, centerY - size / 2)
            diamond.PointB = Vector2.new(centerX + size / 2, centerY)
            diamond.PointC = Vector2.new(centerX, centerY + size / 2)
            diamond.PointD = Vector2.new(centerX - size / 2, centerY)
            diamond.Filled = false
            diamond.Thickness = thickness
            diamond.Transparency = 1 - transparency
            table.insert(crosshairObjects, diamond)

        elseif CrosshairState.Style == "Star" then
            -- Создаём звезду из двух крестов (один повёрнутый на 45 градусов)
            local hLine = Drawing.new("Line")
            hLine.From = Vector2.new(centerX - size, centerY)
            hLine.To = Vector2.new(centerX + size, centerY)
            hLine.Thickness = thickness
            hLine.Transparency = 1 - transparency
            table.insert(crosshairObjects, hLine)

            local vLine = Drawing.new("Line")
            vLine.From = Vector2.new(centerX, centerY - size)
            vLine.To = Vector2.new(centerX, centerY + size)
            vLine.Thickness = thickness
            vLine.Transparency = 1 - transparency
            table.insert(crosshairObjects, vLine)

            local diag1 = Drawing.new("Line")
            diag1.From = Vector2.new(centerX - size / 2, centerY - size / 2)
            diag1.To = Vector2.new(centerX + size / 2, centerY + size / 2)
            diag1.Thickness = thickness
            diag1.Transparency = 1 - transparency
            table.insert(crosshairObjects, diag1)

            local diag2 = Drawing.new("Line")
            diag2.From = Vector2.new(centerX + size / 2, centerY - size / 2)
            diag2.To = Vector2.new(centerX - size / 2, centerY + size / 2)
            diag2.Thickness = thickness
            diag2.Transparency = 1 - transparency
            table.insert(crosshairObjects, diag2)

        elseif CrosshairState.Style == "Plus" then
            local hLine = Drawing.new("Line")
            hLine.From = Vector2.new(centerX - size / 2, centerY)
            hLine.To = Vector2.new(centerX + size / 2, centerY)
            hLine.Thickness = thickness
            hLine.Transparency = 1 - transparency
            table.insert(crosshairObjects, hLine)

            local vLine = Drawing.new("Line")
            vLine.From = Vector2.new(centerX, centerY - size / 2)
            vLine.To = Vector2.new(centerX, centerY + size / 2)
            vLine.Thickness = thickness
            vLine.Transparency = 1 - transparency
            table.insert(crosshairObjects, vLine)

        elseif CrosshairState.Style == "Arrow" then
            local top = Drawing.new("Line")
            top.From = Vector2.new(centerX, centerY - size / 2)
            top.To = Vector2.new(centerX - size / 4, centerY - size / 4)
            top.Thickness = thickness
            top.Transparency = 1 - transparency
            table.insert(crosshairObjects, top)

            local bottom = Drawing.new("Line")
            bottom.From = Vector2.new(centerX, centerY - size / 2)
            bottom.To = Vector2.new(centerX + size / 4, centerY - size / 4)
            bottom.Thickness = thickness
            bottom.Transparency = 1 - transparency
            table.insert(crosshairObjects, bottom)

            local shaft = Drawing.new("Line")
            shaft.From = Vector2.new(centerX, centerY - size / 2)
            shaft.To = Vector2.new(centerX, centerY + size / 2)
            shaft.Thickness = thickness
            shaft.Transparency = 1 - transparency
            table.insert(crosshairObjects, shaft)
        end
    end

    -- Переменная для отслеживания угла вращения
    local rotationAngle = 0

    -- Функция для обновления RGB-цвета
    local function getRGBColor()
        local time = tick() * 2
        local r = math.sin(time) * 127 + 128
        local g = math.sin(time + 2) * 127 + 128
        local b = math.sin(time + 4) * 127 + 128
        return Color3.fromRGB(r, g, b)
    end

    -- Основной цикл обновления прицела
    RunService.RenderStepped:Connect(function(deltaTime)
        if not CrosshairState.Enabled then
            clearCrosshair()
            return
        end

        -- Создаём или обновляем прицел, если изменились настройки
        if #crosshairObjects == 0 or CrosshairState.Style ~= crosshairObjects.style then
            crosshairObjects.style = CrosshairState.Style
            createCrosshair()
        end

        -- Обновляем свойства прицела
        local centerX, centerY = workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2
        local size = CrosshairState.Size
        local thickness = CrosshairState.Thickness
        local transparency = CrosshairState.Transparency

        -- Обновляем вращение, если включено
        if CrosshairState.SpinEnabled then
            rotationAngle = rotationAngle + (CrosshairState.SpinSpeed * deltaTime * 60) -- Скорость вращения
            rotationAngle = rotationAngle % 360 -- Ограничиваем угол до 360 градусов
        else
            rotationAngle = 0
        end

        -- Обновляем цвет (RGB или статический)
        local color = CrosshairState.RGBEnabled and getRGBColor() or CrosshairState.Color

        -- Применяем изменения в зависимости от стиля
        if CrosshairState.Style == "Cross" then
            local hLine, vLine = crosshairObjects[1], crosshairObjects[2]
            hLine.From = Vector2.new(centerX - size * math.cos(math.rad(rotationAngle)), centerY - size * math.sin(math.rad(rotationAngle)))
            hLine.To = Vector2.new(centerX + size * math.cos(math.rad(rotationAngle)), centerY + size * math.sin(math.rad(rotationAngle)))
            hLine.Thickness = thickness
            hLine.Transparency = 1 - transparency
            hLine.Color = color

            vLine.From = Vector2.new(centerX - size * math.sin(math.rad(rotationAngle)), centerY + size * math.cos(math.rad(rotationAngle)))
            vLine.To = Vector2.new(centerX + size * math.sin(math.rad(rotationAngle)), centerY - size * math.cos(math.rad(rotationAngle)))
            vLine.Thickness = thickness
            vLine.Transparency = 1 - transparency
            vLine.Color = color

        elseif CrosshairState.Style == "Dot" then
            local dot = crosshairObjects[1]
            dot.Position = Vector2.new(centerX, centerY)
            dot.Radius = size / 4
            dot.Thickness = thickness
            dot.Transparency = 1 - transparency
            dot.Color = color

        elseif CrosshairState.Style == "Circle" then
            local circle = crosshairObjects[1]
            circle.Position = Vector2.new(centerX, centerY)
            circle.Radius = size / 2
            circle.Thickness = thickness
            circle.Transparency = 1 - transparency
            circle.Color = color

        elseif CrosshairState.Style == "Square" then
            local square = crosshairObjects[1]
            square.Position = Vector2.new(centerX - size / 2, centerY - size / 2)
            square.Size = Vector2.new(size, size)
            square.Thickness = thickness
            square.Transparency = 1 - transparency
            square.Color = color
            square.Rotation = rotationAngle

        elseif CrosshairState.Style == "Triangle" then
            local triangle = crosshairObjects[1]
            triangle.PointA = Vector2.new(centerX, centerY - size / 2)
            triangle.PointB = Vector2.new(centerX - size / 2, centerY + size / 2)
            triangle.PointC = Vector2.new(centerX + size / 2, centerY + size / 2)
            triangle.Thickness = thickness
            triangle.Transparency = 1 - transparency
            triangle.Color = color
            triangle.Rotation = rotationAngle

        elseif CrosshairState.Style == "X" then
            local diag1, diag2 = crosshairObjects[1], crosshairObjects[2]
            diag1.From = Vector2.new(centerX - size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY - size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag1.To = Vector2.new(centerX + size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY + size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag1.Thickness = thickness
            diag1.Transparency = 1 - transparency
            diag1.Color = color

            diag2.From = Vector2.new(centerX + size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY - size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag2.To = Vector2.new(centerX - size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY + size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag2.Thickness = thickness
            diag2.Transparency = 1 - transparency
            diag2.Color = color

        elseif CrosshairState.Style == "Diamond" then
            local diamond = crosshairObjects[1]
            diamond.PointA = Vector2.new(centerX, centerY - size / 2)
            diamond.PointB = Vector2.new(centerX + size / 2, centerY)
            diamond.PointC = Vector2.new(centerX, centerY + size / 2)
            diamond.PointD = Vector2.new(centerX - size / 2, centerY)
            diamond.Thickness = thickness
            diamond.Transparency = 1 - transparency
            diamond.Color = color
            diamond.Rotation = rotationAngle

        elseif CrosshairState.Style == "Star" then
            local hLine, vLine, diag1, diag2 = crosshairObjects[1], crosshairObjects[2], crosshairObjects[3], crosshairObjects[4]
            hLine.From = Vector2.new(centerX - size * math.cos(math.rad(rotationAngle)), centerY - size * math.sin(math.rad(rotationAngle)))
            hLine.To = Vector2.new(centerX + size * math.cos(math.rad(rotationAngle)), centerY + size * math.sin(math.rad(rotationAngle)))
            hLine.Thickness = thickness
            hLine.Transparency = 1 - transparency
            hLine.Color = color

            vLine.From = Vector2.new(centerX - size * math.sin(math.rad(rotationAngle)), centerY + size * math.cos(math.rad(rotationAngle)))
            vLine.To = Vector2.new(centerX + size * math.sin(math.rad(rotationAngle)), centerY - size * math.cos(math.rad(rotationAngle)))
            vLine.Thickness = thickness
            vLine.Transparency = 1 - transparency
            vLine.Color = color

            diag1.From = Vector2.new(centerX - size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY - size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag1.To = Vector2.new(centerX + size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY + size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag1.Thickness = thickness
            diag1.Transparency = 1 - transparency
            diag1.Color = color

            diag2.From = Vector2.new(centerX + size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY - size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag2.To = Vector2.new(centerX - size / 2 * math.cos(math.rad(rotationAngle + 45)), centerY + size / 2 * math.sin(math.rad(rotationAngle + 45)))
            diag2.Thickness = thickness
            diag2.Transparency = 1 - transparency
            diag2.Color = color

        elseif CrosshairState.Style == "Plus" then
            local hLine, vLine = crosshairObjects[1], crosshairObjects[2]
            hLine.From = Vector2.new(centerX - size / 2 * math.cos(math.rad(rotationAngle)), centerY - size / 2 * math.sin(math.rad(rotationAngle)))
            hLine.To = Vector2.new(centerX + size / 2 * math.cos(math.rad(rotationAngle)), centerY + size / 2 * math.sin(math.rad(rotationAngle)))
            hLine.Thickness = thickness
            hLine.Transparency = 1 - transparency
            hLine.Color = color

            vLine.From = Vector2.new(centerX - size / 2 * math.sin(math.rad(rotationAngle)), centerY + size / 2 * math.cos(math.rad(rotationAngle)))
            vLine.To = Vector2.new(centerX + size / 2 * math.sin(math.rad(rotationAngle)), centerY - size / 2 * math.cos(math.rad(rotationAngle)))
            vLine.Thickness = thickness
            vLine.Transparency = 1 - transparency
            vLine.Color = color

        elseif CrosshairState.Style == "Arrow" then
            local top, bottom, shaft = crosshairObjects[1], crosshairObjects[2], crosshairObjects[3]
            top.From = Vector2.new(centerX, centerY - size / 2)
            top.To = Vector2.new(centerX - size / 4, centerY - size / 4)
            top.Thickness = thickness
            top.Transparency = 1 - transparency
            top.Color = color
            top.Rotation = rotationAngle

            bottom.From = Vector2.new(centerX, centerY - size / 2)
            bottom.To = Vector2.new(centerX + size / 4, centerY - size / 4)
            bottom.Thickness = thickness
            bottom.Transparency = 1 - transparency
            bottom.Color = color
            bottom.Rotation = rotationAngle

            shaft.From = Vector2.new(centerX, centerY - size / 2)
            shaft.To = Vector2.new(centerX, centerY + size / 2)
            shaft.Thickness = thickness
            shaft.Transparency = 1 - transparency
            shaft.Color = color
            shaft.Rotation = rotationAngle
        end
    end)
end

-- Инициализация Crosshair
Crosshair()
