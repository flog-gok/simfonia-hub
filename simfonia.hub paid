local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/Library.lua"))()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
local camera = workspace.CurrentCamera or workspace:WaitForChild("CurrentCamera")
local defaultFOV = camera.FieldOfView -- Сохраняем стандартный FOV
local lastState = nil -- Для отслеживания состояния прыжка
local titles = {} -- Список титулов
local rgbTime = 0 -- Для RGB-анимации
local staffFrame = nil -- Фрейм для Staff Online
local staffLabels = {} -- Метки для игроков из белого списка
local dragging = false -- Для перетаскивания Staff Online
local dragOffset = Vector2.new(0, 0) -- Смещение при перетаскивании

-- Создаём окно "Simfonia HUB"
local Window = Library:CreateWindow({
    Title = "Simfonia.HUB v2.4",
    Center = true,
    AutoShow = true
})

-- Создаём вкладки
local Tabs = {
    Legit = Window:AddTab("Legit"),
    Render = Window:AddTab("Render"),
    Visual = Window:AddTab("Visual"),
    Hacks = Window:AddTab("Hacks"),
    Settings = Window:AddTab("Settings")
}

-- Состояние ESP
local ESPState = {
    Enabled = false,
    Studs = false,
    Name = false,
    HP = false,
    Color = Color3.fromRGB(0, 255, 0),
    WeaponEnabled = false
}

-- Состояние Object ESP
local ObjectESPState = {
    Enabled = false,
    SelectedObjects = {},
    MaxRecyclerHelicopter = 20,
    MaxCupboard = 10,
    Color = Color3.fromRGB(0, 255, 0),
    NewObjectColor = Color3.fromRGB(0, 0, 255),
    NewObjectDuration = 20
}

local OreESPState = {
    Enabled = false,
    SelectedOres = {},
    MaxPerOre = 10,
    Color = Color3.fromRGB(0, 255, 0)
}

local VisualState = {
    ViewModelEnabled = false,
    FOV = 70,
    JumpCircleEnabled = false,
    CircleSpeed = 50, -- Скорость исчезания (1-100, 50 по умолчанию ~5 секунд)
    CircleColor = "BlueFade", -- Цвет по умолчанию
    AvailableColors = {"BlueFade", "RGBBlue", "RGB"}
}

local TitlesState = {
    Enabled = false,
    RGBEnabled = false
}

local StaffOnlineState = {
    Enabled = false,
    Whitelist = {"igarokmax", "33jeii2", "leon_vent4", "Alex_BossGr", ""}
}

local FullbrightState = {
    Enabled = false
}

local NoFogState = {
    Enabled = false
}

local NoSkyState = {
    Enabled = false
}

local SpeedhackState = {
    Enabled = false,
    Speed = 20, -- Скорость по умолчанию
    Bind = nil -- По умолчанию нет бинда
}

local BunnyHopState = {
    Enabled = false
}

local ForceSpeedState = {
    Enabled = false,
    Speed = 26 -- Фиксированная скорость
}

local FlyState = {
    Enabled = false,
    Mode = "FreeFly", -- Режим по умолчанию
    AvailableModes = {"FreeFly", "JumpFly", "ClockFly"},
    Speed = 20 -- Скорость для FreeFly и JumpFly
}

local SpiderState = {
    Enabled = false,
    Speed = 10 -- Скорость по умолчанию (10-40)
}

local FreeCamState = {
    Enabled = false,
    Mode = "Middle", -- Режим по умолчанию
    AvailableModes = {"Middle", "Button"},
    Speed = 50 -- Скорость по умолчанию для Button (20-100)
}

-- Обновляем SkyState, добавляя Enabled
local SkyState = {
    Enabled = false, -- Добавляем тоггл для включения/выключения
    CycleMode = "Realistic",
    AvailableCycles = {"Realistic", "Light", "DeepNight"}
}

local CrosshairState = {
    Enabled = false,
    Type = "DotCircle", -- По умолчанию круг с точкой
    AvailableTypes = {"DotCircle", "Cross"},
    RGBEnabled = false,
    SpinEnabled = false,
    SpinSpeed = 1 -- Скорость вращения (1-10)
}

local VisualToolState = {
    SelectedTool = "Ak1", -- Предмет по умолчанию
    AvailableTools = {"Ak1", "Revolver", "Bow", "Thompson", "5.56 Rifle ammo"},
    Amount = 1 -- Количество по умолчанию
}

local ShowBackpackState = {
    WindowVisible = false,
    SelectedBackpack = nil
}

local AimbotState = {
    Enabled = false,
    Radius = 50,          -- Радиус действия (20-100)
    Smoothness = 50,      -- Скорость наводки (1-100%)
    SkipWall = false,     -- Проверка стен
    FOVEnabled = false,   -- Включение/выключение FOV
    FOVSize = 200,        -- Размер FOV (1-700)
    SnaplineEnabled = false, -- Включение/выключение линии
    BindType = "Mouse",   -- Тип бинда: "Mouse" или "Key"
    MouseBind = Enum.UserInputType.MouseButton2, -- Правая кнопка мыши по умолчанию
    KeyBind = nil,        -- Нет клавиши по умолчанию
    TargetPart = "Head"   -- Часть тела: "Head" или "Body"
}

local SilentAimState = {
    Enabled = false,
    FOVEnabled = false,   -- Включение/выключение FOV
    FOVSize = 200,        -- Размер FOV (1-700)
    SnaplineEnabled = false, -- Включение/выключение линии
    TargetPart = "Head"   -- Часть тела: "Head" или "Body"
}

local HitboxExpanderState = {
    Enabled = false,
    Size = 1,             -- Размер хитбокса (1-8 studs)
    Transparency = 0.5    -- Прозрачность (0-1)
}

local AntiKickState = {
    Enabled = false,
    Hooked = false,
    TestKickActive = false -- Флаг для тестового кика
}

local SIMAIState = {
    Enabled = false
}

local LegitResetState = {
    Enabled = false,
    KeyBind = nil,    -- Для клавиш
    MouseBind = nil   -- Для кнопок мыши
}

local HWHState = {
    TwisterEnabled = false,
    TwisterSpeed = 10,     -- Скорость вращения (10-2000)
}

local FPSState = {
    DeleteTextureEnabled = false,
    XRayEnabled = false,
    XRayTransparency = 0.5,
    ExitGameEnabled = false,  -- Добавляем тоггл для Exit Game
    ExitGameKeyBind = nil,
    ExitGameMouseBind = nil
}

-- Хранилище оригинальных свойств текстур
local originalTextureData = {}

-- UI для Settings (если вкладки ещё нет, создаём)
local SettingsGroup = Tabs.Settings and Tabs.Settings:AddLeftGroupbox("Settings") or Tabs.Main:AddLeftGroupbox("Settings")

-- Anti Kick
SettingsGroup:AddToggle("AntiKickEnabled", {
    Text = "Anti Kick",
    Default = AntiKickState.Enabled,
    Tooltip = "Перехватывает серверные и локальные кики"
})
Toggles.AntiKickEnabled:OnChanged(function()
    AntiKickState.Enabled = Toggles.AntiKickEnabled.Value
    Library:Notify("Anti Kick " .. (AntiKickState.Enabled and "включён" or "выключен"))
end)

SettingsGroup:AddButton({
    Text = "Проверить Anti Kick",
    Func = function()
        Library:Notify("Тестируем Anti Kick...")
        task.wait(0.1) -- Небольшая задержка для уведомления
        AntiKickState.TestKickActive = true -- Устанавливаем флаг теста
        -- Симулируем локальное уведомление о кике
        local screenGui = Instance.new("ScreenGui")
        screenGui.Parent = game:GetService("CoreGui")
        local testMessage = Instance.new("TextLabel")
        testMessage.Size = UDim2.new(0, 400, 0, 50)
        testMessage.Position = UDim2.new(0.5, -200, 0.5, -25)
        testMessage.BackgroundTransparency = 0.5
        testMessage.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        testMessage.Text = "Тестовый кик для проверки Anti Kick"
        testMessage.TextColor3 = Color3.fromRGB(255, 255, 255)  --vot tyt ya nasral
        testMessage.TextScaled = true
        testMessage.Parent = screenGui
        -- Вызываем тестовый кик
        local success, result = pcall(function()
            LocalPlayer:Kick("Тестовый кик для проверки Anti Kick")
        end)
        -- Проверяем, если кик прошёл без перехвата
        if success and AntiKickState.Enabled then
            task.wait(0.5) -- Даём время на перехват
            Library:Notify("Тестовый антикик не сработал!", 5)
            AntiKickState.TestKickActive = false
            if screenGui then screenGui:Destroy() end
        end
    end,
    Tooltip = "Вызывает тестовый кик для проверки Anti Kick"
})

-- SIM AI
SettingsGroup:AddToggle("SIMAIEnabled", {
    Text = "SIM AI",
    Default = SIMAIState.Enabled,
    Tooltip = "Активирует SIM AI для выполнения команд /hellps - команды" --добавить новые команды нужно
})
Toggles.SIMAIEnabled:OnChanged(function()
    SIMAIState.Enabled = Toggles.SIMAIEnabled.Value
    if SIMAIState.Enabled then
        -- Отправляем сообщение в чат с фиолетовым ником через TextChatService
        local TextChatService = game:GetService("TextChatService")
        local textChannels = TextChatService:FindFirstChild("TextChannels")
        if textChannels then
            local rbxtsChannel = textChannels:FindFirstChild("RBXGeneral") or textChannels:FindFirstChild("RBXSystem")
            if rbxtsChannel then
                rbxtsChannel:DisplaySystemMessage(
                    '<font color="rgb(128,0,128)">SIM AI:</font> SIM AI был активирован.',
                    "System"
                )
            end
        end
        -- Локальное сообщение от SIM AI
        local screenGui = Instance.new("ScreenGui")
        screenGui.Parent = game:GetService("CoreGui")
        local message = Instance.new("TextLabel")
        message.Size = UDim2.new(0, 400, 0, 50)
        message.Position = UDim2.new(0.5, -200, 0.5, -25)
        message.BackgroundTransparency = 0.5
        message.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        message.Text = "SIM AI: Привет, чем могу быть полезен? Для включения команд сделайте /hellps."
        message.TextColor3 = Color3.fromRGB(128, 0, 128) -- Фиолетовый текст
        message.TextScaled = true
        message.Parent = screenGui
        task.spawn(function()
            task.wait(5)
            screenGui:Destroy()
        end)
    end
    Library:Notify("SIM AI " .. (SIMAIState.Enabled and "включён" or "выключен"))
end)

-- UI для FPS
local FPSGroup = Tabs.Settings:AddLeftGroupbox("FPS")

-- Delete Texture
FPSGroup:AddToggle("DeleteTextureEnabled", {
    Text = "Delete Texture",
    Default = FPSState.DeleteTextureEnabled,
    Tooltip = "Удаляет все текстуры, оставляя модели и материалы"
})
Toggles.DeleteTextureEnabled:OnChanged(function()
    FPSState.DeleteTextureEnabled = Toggles.DeleteTextureEnabled.Value
    Library:Notify("Delete Texture " .. (FPSState.DeleteTextureEnabled and "включён" or "выключен"))
end)

-- X-Ray
FPSGroup:AddToggle("XRayEnabled", {
    Text = "X-Ray",
    Default = FPSState.XRayEnabled,
    Tooltip = "Делает текстуры полупрозрачными"
})
Toggles.XRayEnabled:OnChanged(function()
    FPSState.XRayEnabled = Toggles.XRayEnabled.Value
    Library:Notify("X-Ray " .. (FPSState.XRayEnabled and "включён" or "выключен"))
end)

FPSGroup:AddSlider("XRayTransparency", {
    Text = "Прозрачность X-Ray",
    Default = FPSState.XRayTransparency,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Tooltip = "Настройка прозрачности текстур (0.1-1)"
})
Options.XRayTransparency:OnChanged(function()
    FPSState.XRayTransparency = Options.XRayTransparency.Value
end)

-- Exit Game
FPSGroup:AddToggle("ExitGameEnabled", {
    Text = "Exit Game",
    Default = FPSState.ExitGameEnabled,
    Tooltip = "Включает бинд для кика из игры"
})
Toggles.ExitGameEnabled:OnChanged(function()
    FPSState.ExitGameEnabled = Toggles.ExitGameEnabled.Value
    Library:Notify("Exit Game " .. (FPSState.ExitGameEnabled and "включён" or "выключен"))
end)

FPSGroup:AddButton({
    Text = "Назначить бинд Exit Game",
    Func = function()
        Library:Notify("Нажми клавишу или кнопку мыши чтобы забиндить Exit Game")
        task.wait(0.1) -- Задержка для уведомления
        local binding = true
        local connection
        connection = UserInputService.InputBegan:Connect(function(input)
            if binding then
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    FPSState.ExitGameKeyBind = input.KeyCode
                    FPSState.ExitGameMouseBind = nil -- Сбрасываем бинд мыши
                    Library:Notify("Бинд Exit Game установлен: " .. input.KeyCode.Name)
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 or 
                       input.UserInputType == Enum.UserInputType.MouseButton2 or 
                       input.UserInputType == Enum.UserInputType.MouseButton3 then
                    FPSState.ExitGameMouseBind = input.UserInputType
                    FPSState.ExitGameKeyBind = nil -- Сбрасываем бинд клавиши
                    Library:Notify("Бинд Exit Game установлен: " .. input.UserInputType.Name)
                end
                binding = false
                connection:Disconnect()
            end
        end)
    end,
    Tooltip = "Назначить бинд для кика из игры"
})

FPSGroup:AddButton({
    Text = "Удалить бинд Exit Game",
    Func = function()
        FPSState.ExitGameKeyBind = nil
        FPSState.ExitGameMouseBind = nil
        Library:Notify("Бинд Exit Game удалён")
    end,
    Tooltip = "Удаляет текущий бинд Exit Game"
})

-- Rejoin
FPSGroup:AddButton({
    Text = "Rejoin",
    Func = function()
        Library:Notify("Переподключение к игре...")
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
    end,
    Tooltip = "Переподключает к текущей игре"
})

-- Legit Reset (новая группа справа)
local LegitResetGroup = Tabs.Settings:AddRightGroupbox("Legit Reset")

-- Legit Reset Toggle
LegitResetGroup:AddToggle("LegitResetEnabled", {
    Text = "Legit Reset",
    Default = LegitResetState.Enabled,
    Tooltip = "Включает легитный ресет персонажа по бинду"
})
Toggles.LegitResetEnabled:OnChanged(function()
    LegitResetState.Enabled = Toggles.LegitResetEnabled.Value
    Library:Notify("Legit Reset " .. (LegitResetState.Enabled and "включён" or "выключен"))
end)

-- Назначить бинд для Legit Reset
LegitResetGroup:AddButton({
    Text = "Назначить бинд Legit Reset",
    Func = function()
        Library:Notify("Нажми клавишу или кнопку мыши чтобы забиндить Legit Reset")
        task.wait(0.1) -- Задержка для уведомления
        local binding = true
        local connection
        connection = UserInputService.InputBegan:Connect(function(input)
            if binding then
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    LegitResetState.KeyBind = input.KeyCode
                    LegitResetState.MouseBind = nil -- Сбрасываем бинд мыши
                    Library:Notify("Бинд Legit Reset установлен: " .. input.KeyCode.Name)
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 or 
                       input.UserInputType == Enum.UserInputType.MouseButton2 or 
                       input.UserInputType == Enum.UserInputType.MouseButton3 then
                    LegitResetState.MouseBind = input.UserInputType
                    LegitResetState.KeyBind = nil -- Сбрасываем бинд клавиши
                    Library:Notify("Бинд Legit Reset установлен: " .. input.UserInputType.Name)
                end
                binding = false
                connection:Disconnect()
            end
        end)
    end,
    Tooltip = "Назначить бинд для легитного ресета"
})

-- Удалить бинд для Legit Reset
LegitResetGroup:AddButton({
    Text = "Удалить бинд Legit Reset",
    Func = function()
        LegitResetState.KeyBind = nil
        LegitResetState.MouseBind = nil
        Library:Notify("Бинд Legit Reset удалён")
    end,
    Tooltip = "Удаляет текущий бинд Legit Reset"
})

-- Anti Kick
local function setupAntiKick()
    if AntiKickState.Hooked then return end

    -- Перехват через метатаблицу
    local Players = game:GetService("Players")
    local mt = getrawmetatable(game)
    setreadonly(mt, false) -- Делаем метатаблицу доступной для записи

    local oldNamecall = mt.__namecall

    mt.__namecall = newcclosure(function(self, ...)
        local args = {...}
        local method = getnamecallmethod()
        
        if method == "Kick" and self == Players.LocalPlayer and AntiKickState.Enabled then
            warn("Античит пытался вас кикнуть! Анти-кик активирован.")
            Library:Notify("Вас обнаружил АНТИЧИТ, поэтому мы вас спасли!", 5)
            task.spawn(function()
                task.wait(0.1)
                game:Shutdown()
            end)
            return nil
        end

        return oldNamecall(self, unpack(args))
    end)

    -- Проверка через CoreGui для локальных кик-уведомлений
    local coreGui = game:GetService("CoreGui")
    local function checkKickMessage()
        for _, gui in pairs(coreGui:GetChildren()) do
            if (gui:IsA("Message") or gui:IsA("TextLabel")) and gui.Text then
                local text = gui.Text:lower()
                if text:find("kick") or text:find("disconnected") or text:find("banned") or text:find("тестовый кик") then
                    if AntiKickState.Enabled then
                        gui:Destroy() -- Удаляем сообщение о кике
                        Library:Notify("Вас обнаружил АНТИЧИТ, поэтому мы вас спасли!", 5)
                        task.spawn(function()
                            task.wait(0.1)
                            game:Shutdown()
                        end)
                        AntiKickState.TestKickActive = false
                    elseif not AntiKickState.TestKickActive then
                        gui:Destroy() -- Удаляем сообщение, если это не тест
                    end
                end
            end
        end
    end

    -- Перехват сетевых отключений
    local networkClient = game:GetService("NetworkClient")
    local originalDisconnect = networkClient.Connection.Disconnect
    networkClient.Connection.Disconnect = function(...)
        if AntiKickState.Enabled then
            Library:Notify("Вас обнаружил АНТИЧИТ, поэтому мы вас спасли!", 5)
            task.spawn(function()
                task.wait(0.1)
                game:Shutdown()
            end)
            return
        end
        return originalDisconnect(...)
    end

    -- Запускаем проверку в цикле
    RunService.Heartbeat:Connect(checkKickMessage)

    AntiKickState.Hooked = true
end

-- Отключаем перехват, если выключаем Anti Kick
local function disableAntiKick()
    if not AntiKickState.Hooked then return end

    -- Восстанавливаем метатаблицу
    local mt = getrawmetatable(game)
    if mt.__namecall ~= mt.__index then
        mt.__namecall = mt.__index
        setreadonly(mt, true) -- Возвращаем readonly
    end

    -- Восстанавливаем оригинальный Disconnect
    local networkClient = game:GetService("NetworkClient")
    if networkClient.Connection.Disconnect ~= networkClient.Connection.Disconnect then
        networkClient.Connection.Disconnect = networkClient.Connection.Disconnect
    end

    AntiKickState.Hooked = false
end

-- Обновляем Anti Kick при изменении состояния
AntiKickState.EnabledChanged = AntiKickState.EnabledChanged or {}
RunService.Heartbeat:Connect(function()
    if AntiKickState.Enabled ~= AntiKickState.EnabledChanged.Enabled then
        AntiKickState.EnabledChanged.Enabled = AntiKickState.Enabled
        if AntiKickState.Enabled then
            setupAntiKick()
        else
            disableAntiKick()
        end
    end
end)

local originalHitboxData = {} -- Для хранения оригинальных данных хитбоксов

-- UI для Legit
local LegitGroup = Tabs.Legit:AddLeftGroupbox("Legit Hacks")

-- Aimbot
LegitGroup:AddToggle("AimbotEnabled", {
    Text = "Aimbot",
    Default = AimbotState.Enabled,
    Tooltip = "Автоматически наводит прицел на врагов"
})
Toggles.AimbotEnabled:OnChanged(function()
    AimbotState.Enabled = Toggles.AimbotEnabled.Value
    Library:Notify("Aimbot " .. (AimbotState.Enabled and "включён" or "выключен"))
end)

LegitGroup:AddDropdown("AimbotTargetPart", {
    Text = "Целевая часть",
    Default = AimbotState.TargetPart,
    Values = {"Head", "Body"},
    Tooltip = "Выберите часть тела для прицеливания"
})
Options.AimbotTargetPart:OnChanged(function()
    AimbotState.TargetPart = Options.AimbotTargetPart.Value
end)

LegitGroup:AddSlider("AimbotRadius", {
    Text = "Радиус действия",
    Default = AimbotState.Radius,
    Min = 20,
    Max = 100,
    Rounding = 0,
    Tooltip = "Радиус поиска цели (20-100)"
})
Options.AimbotRadius:OnChanged(function()
    AimbotState.Radius = Options.AimbotRadius.Value
end)

LegitGroup:AddSlider("AimbotSmoothness", {
    Text = "Плавность наводки",
    Default = AimbotState.Smoothness,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Tooltip = "Скорость наводки (1-100%)"
})
Options.AimbotSmoothness:OnChanged(function()
    AimbotState.Smoothness = Options.AimbotSmoothness.Value
end)

LegitGroup:AddToggle("AimbotSkipWall", {
    Text = "Пропускать стены",
    Default = AimbotState.SkipWall,
    Tooltip = "Игнорировать стены при наводке"
})
Toggles.AimbotSkipWall:OnChanged(function()
    AimbotState.SkipWall = Toggles.AimbotSkipWall.Value
end)

LegitGroup:AddToggle("AimbotFOVEnabled", {
    Text = "Включить FOV",
    Default = AimbotState.FOVEnabled,
    Tooltip = "Ограничивать зону действия FOV"
})
Toggles.AimbotFOVEnabled:OnChanged(function()
    AimbotState.FOVEnabled = Toggles.AimbotFOVEnabled.Value
end)

LegitGroup:AddSlider("AimbotFOVSize", {
    Text = "Размер FOV",
    Default = AimbotState.FOVSize,
    Min = 1,
    Max = 700,
    Rounding = 0,
    Tooltip = "Размер поля зрения (1-700)"
})
Options.AimbotFOVSize:OnChanged(function()
    AimbotState.FOVSize = Options.AimbotFOVSize.Value
end)

LegitGroup:AddToggle("AimbotSnaplineEnabled", {
    Text = "Включить Snapline",
    Default = AimbotState.SnaplineEnabled,
    Tooltip = "Показывать линию к цели"
})
Toggles.AimbotSnaplineEnabled:OnChanged(function()
    AimbotState.SnaplineEnabled = Toggles.AimbotSnaplineEnabled.Value
end)

LegitGroup:AddDropdown("AimbotBindType", {
    Text = "Тип бинда",
    Default = AimbotState.BindType,
    Values = {"Mouse", "Key"},
    Tooltip = "Выберите тип бинда: мышь или клавиша"
})
Options.AimbotBindType:OnChanged(function()
    AimbotState.BindType = Options.AimbotBindType.Value
end)

LegitGroup:AddButton({
    Text = "Назначить бинд Aimbot",
    Func = function()
        Library:Notify("Нажми клавишу или кнопку мыши чтобы забиндить Aimbot")
        task.wait(0.1) -- Небольшая задержка для отображения уведомления
        local binding = true
        local connection
        connection = UserInputService.InputBegan:Connect(function(input)
            if binding then
                if AimbotState.BindType == "Key" and input.UserInputType == Enum.UserInputType.Keyboard then
                    AimbotState.KeyBind = input.KeyCode
                    Library:Notify("Бинд Aimbot установлен: " .. input.KeyCode.Name)
                elseif AimbotState.BindType == "Mouse" and 
                       (input.UserInputType == Enum.UserInputType.MouseButton1 or 
                        input.UserInputType == Enum.UserInputType.MouseButton2 or 
                        input.UserInputType == Enum.UserInputType.MouseButton3) then
                    AimbotState.MouseBind = input.UserInputType
                    Library:Notify("Бинд Aimbot установлен: " .. input.UserInputType.Name)
                end
                binding = false
                connection:Disconnect()
            end
        end)
    end,
    Tooltip = "Назначить бинд для активации Aimbot"
})

LegitGroup:AddButton({
    Text = "Удалить бинд Aimbot",
    Func = function()
        if AimbotState.BindType == "Mouse" then
            AimbotState.MouseBind = nil
        else
            AimbotState.KeyBind = nil
        end
        Library:Notify("Бинд Aimbot удалён")
    end,
    Tooltip = "Удаляет текущий бинд Aimbot"
})

-- UI для Rage
local RageGroup = Tabs.Legit:AddRightGroupbox("Rage Hacks")

-- Silent Aim
RageGroup:AddToggle("SilentAimEnabled", {
    Text = "Silent Aim",
    Default = SilentAimState.Enabled,
    Tooltip = "Тихо наводит на цель при стрельбе"
})
Toggles.SilentAimEnabled:OnChanged(function()
    SilentAimState.Enabled = Toggles.SilentAimEnabled.Value
    Library:Notify("Silent Aim " .. (SilentAimState.Enabled and "включён" or "выключен"))
end)

RageGroup:AddDropdown("SilentAimTargetPart", {
    Text = "Целевая часть",
    Default = SilentAimState.TargetPart,
    Values = {"Head", "Body"},
    Tooltip = "Выберите часть тела для наводки"
})
Options.SilentAimTargetPart:OnChanged(function()
    SilentAimState.TargetPart = Options.SilentAimTargetPart.Value
end)

RageGroup:AddToggle("SilentAimFOVEnabled", {
    Text = "Включить FOV",
    Default = SilentAimState.FOVEnabled,
    Tooltip = "Ограничивать зону действия FOV"
})
Toggles.SilentAimFOVEnabled:OnChanged(function()
    SilentAimState.FOVEnabled = Toggles.SilentAimFOVEnabled.Value
end)

RageGroup:AddSlider("SilentAimFOVSize", {
    Text = "Размер FOV",
    Default = SilentAimState.FOVSize,
    Min = 1,
    Max = 700,
    Rounding = 0,
    Tooltip = "Размер поля зрения (1-700)"
})
Options.SilentAimFOVSize:OnChanged(function()
    SilentAimState.FOVSize = Options.SilentAimFOVSize.Value
end)

RageGroup:AddToggle("SilentAimSnaplineEnabled", {
    Text = "Включить Snapline",
    Default = SilentAimState.SnaplineEnabled,
    Tooltip = "Показывать линию к цели"
})
Toggles.SilentAimSnaplineEnabled:OnChanged(function()
    SilentAimState.SnaplineEnabled = Toggles.SilentAimSnaplineEnabled.Value
end)

RageGroup:AddButton({
    Text = "Назначить бинд Silent Aim",
    Func = function()
        Library:Notify("Нажми клавишу или кнопку мыши чтобы забиндить Silent Aim")
        task.wait(0.1) -- Задержка для уведомления
        local binding = true
        local connection
        connection = UserInputService.InputBegan:Connect(function(input)
            if binding then
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    SilentAimState.KeyBind = input.KeyCode
                    Library:Notify("Бинд Silent Aim установлен: " .. input.KeyCode.Name)
                elseif input.UserInputType == Enum.UserInputType.MouseButton1 or 
                       input.UserInputType == Enum.UserInputType.MouseButton2 or 
                       input.UserInputType == Enum.UserInputType.MouseButton3 then
                    SilentAimState.MouseBind = input.UserInputType
                    Library:Notify("Бинд Silent Aim установлен: " .. input.UserInputType.Name)
                end
                binding = false
                connection:Disconnect()
            end
        end)
    end,
    Tooltip = "Назначить бинд для активации Silent Aim"
})

RageGroup:AddButton({
    Text = "Удалить бинд Silent Aim",
    Func = function()
        SilentAimState.KeyBind = nil
        SilentAimState.MouseBind = nil
        Library:Notify("Бинд Silent Aim удалён")
    end,
    Tooltip = "Удаляет текущий бинд Silent Aim"
})

-- UI для Hitbox Expander
local HitboxExpanderGroup = Tabs.Legit:AddLeftGroupbox("Hitbox Expander")

-- Hitbox Expander
HitboxExpanderGroup:AddToggle("HitboxExpanderEnabled", {
    Text = "Hitbox Expander",
    Default = HitboxExpanderState.Enabled,
    Tooltip = "Увеличивает хитбоксы врагов"
})
Toggles.HitboxExpanderEnabled:OnChanged(function()
    HitboxExpanderState.Enabled = Toggles.HitboxExpanderEnabled.Value
    Library:Notify("Hitbox Expander " .. (HitboxExpanderState.Enabled and "включён" or "выключен"))
end)

HitboxExpanderGroup:AddSlider("HitboxExpanderSize", {
    Text = "Размер хитбокса",
    Default = HitboxExpanderState.Size,
    Min = 1,
    Max = 8,
    Rounding = 1,
    Tooltip = "Размер хитбокса (1-8 studs)"
})
Options.HitboxExpanderSize:OnChanged(function()
    HitboxExpanderState.Size = Options.HitboxExpanderSize.Value
end)

HitboxExpanderGroup:AddSlider("HitboxExpanderTransparency", {
    Text = "Прозрачность",
    Default = HitboxExpanderState.Transparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Tooltip = "Прозрачность хитбокса (0-1)"
})
Options.HitboxExpanderTransparency:OnChanged(function()
    HitboxExpanderState.Transparency = Options.HitboxExpanderTransparency.Value
end)

-- UI для HWH
local HWHGroup = Tabs.Legit:AddRightGroupbox("HWH")

-- Twister
HWHGroup:AddToggle("TwisterEnabled", {
    Text = "Twister",
    Default = HWHState.TwisterEnabled,
    Tooltip = "Вращает персонажа вокруг своей оси"
})
Toggles.TwisterEnabled:OnChanged(function()
    HWHState.TwisterEnabled = Toggles.TwisterEnabled.Value
    Library:Notify("Twister " .. (HWHState.TwisterEnabled and "включён" or "выключен"))
end)

HWHGroup:AddSlider("TwisterSpeed", {
    Text = "Скорость вращения",
    Default = HWHState.TwisterSpeed,
    Min = 10,
    Max = 2000,
    Rounding = 0,
    Tooltip = "Скорость вращения (10-2000)"
})
Options.TwisterSpeed:OnChanged(function()
    HWHState.TwisterSpeed = Options.TwisterSpeed.Value
end)

-- UI для ESP в Render (слева)
local RenderGroupESP = Tabs.Render:AddLeftGroupbox("ESP")

RenderGroupESP:AddToggle("ESPEnabled", {
    Text = "Включить ESP",
    Default = ESPState.Enabled,
    Tooltip = "Включает/выключает ESP для игроков"
})
Toggles.ESPEnabled:OnChanged(function()
    ESPState.Enabled = Toggles.ESPEnabled.Value
    Library:Notify("ESP " .. (ESPState.Enabled and "включён" or "выключен"))
end)

RenderGroupESP:AddToggle("ESPStuds", {
    Text = "Показывать расстояние (Studs)",
    Default = ESPState.Studs,
    Tooltip = "Отображает расстояние до игроков в studs"
})
Toggles.ESPStuds:OnChanged(function()
    ESPState.Studs = Toggles.ESPStuds.Value
end)

RenderGroupESP:AddToggle("ESPName", {
    Text = "Показывать имя",
    Default = ESPState.Name,
    Tooltip = "Отображает имена игроков"
})
Toggles.ESPName:OnChanged(function()
    ESPState.Name = Toggles.ESPName.Value
end)

RenderGroupESP:AddToggle("ESPHP", {
    Text = "Показывать HP",
    Default = ESPState.HP,
    Tooltip = "Отображает здоровье игроков"
})
Toggles.ESPHP:OnChanged(function()
    ESPState.HP = Toggles.ESPHP.Value
end)

RenderGroupESP:AddToggle("ESPWeapon", {
    Text = "Показывать оружие",
    Default = ESPState.WeaponEnabled,
    Tooltip = "Отображает текущее оружие игроков"
})
Toggles.ESPWeapon:OnChanged(function()
    ESPState.WeaponEnabled = Toggles.ESPWeapon.Value
end)

RenderGroupESP:AddButton({
    Text = "Сбросить настройки ESP",
    Func = function()
        ESPState.Enabled = false
        ESPState.Studs = false
        ESPState.Name = false
        ESPState.HP = false
        ESPState.WeaponEnabled = false
        
        Toggles.ESPEnabled:SetValue(false)
        Toggles.ESPStuds:SetValue(false)
        Toggles.ESPName:SetValue(false)
        Toggles.ESPHP:SetValue(false)
        Toggles.ESPWeapon:SetValue(false)
        
        Library:Notify("Настройки ESP сброшены!")
    end,
    Tooltip = "Сбрасывает все настройки ESP к стандартным"
})

-- UI для Object ESP в Render (справа)
local RenderGroupObjectESP = Tabs.Render:AddRightGroupbox("Object ESP")

RenderGroupObjectESP:AddToggle("ObjectESPEnabled", {
    Text = "Включить Object ESP",
    Default = ObjectESPState.Enabled,
    Tooltip = "Включает/выключает ESP для объектов"
})
Toggles.ObjectESPEnabled:OnChanged(function()
    ObjectESPState.Enabled = Toggles.ObjectESPEnabled.Value
    Library:Notify("Object ESP " .. (ObjectESPState.Enabled and "включён" or "выключен"))
end)

RenderGroupObjectESP:AddDropdown("ObjectESPObjects", {
    Text = "Выбрать объекты",
    Default = {},
    Multi = true,
    Values = {"Recycler", "Helicopter", "Cupboard", "Crate", "Barrel"},
    Tooltip = "Выберите объекты для отображения"
})
Options.ObjectESPObjects:OnChanged(function()
    ObjectESPState.SelectedObjects = Options.ObjectESPObjects.Value
end)

RenderGroupObjectESP:AddSlider("ObjectESPMaxRecyclerHeli", {
    Text = "Лимит Recycler/Helicopter",
    Default = ObjectESPState.MaxRecyclerHelicopter,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Tooltip = "Максимальное количество Recycler и Helicopter"
})
Options.ObjectESPMaxRecyclerHeli:OnChanged(function()
    ObjectESPState.MaxRecyclerHelicopter = Options.ObjectESPMaxRecyclerHeli.Value
end)

RenderGroupObjectESP:AddSlider("ObjectESPMaxCupboard", {
    Text = "Лимит Cupboard",
    Default = ObjectESPState.MaxCupboard,
    Min = 1,
    Max = 30,
    Rounding = 0,
    Tooltip = "Максимальное количество Cupboard"
})
Options.ObjectESPMaxCupboard:OnChanged(function()
    ObjectESPState.MaxCupboard = Options.ObjectESPMaxCupboard.Value
end)

RenderGroupObjectESP:AddSlider("ObjectESPNewDuration", {
    Text = "Длительность подсветки (сек)",
    Default = ObjectESPState.NewObjectDuration,
    Min = 5,
    Max = 60,
    Rounding = 0,
    Tooltip = "Как долго новые объекты подсвечиваются другим цветом"
})
Options.ObjectESPNewDuration:OnChanged(function()
    ObjectESPState.NewObjectDuration = Options.ObjectESPNewDuration.Value
end)

RenderGroupObjectESP:AddToggle("OreESPEnabled", {
    Text = "Включить Ore ESP",
    Default = OreESPState.Enabled,
    Tooltip = "Включает/выключает ESP для руды"
})
Toggles.OreESPEnabled:OnChanged(function()
    OreESPState.Enabled = Toggles.OreESPEnabled.Value
    Library:Notify("Ore ESP " .. (OreESPState.Enabled and "включён" or "выключен"))
end)

RenderGroupObjectESP:AddDropdown("OreESPSelected", {
    Text = "Выбрать руду",
    Default = {},
    Multi = true,
    Values = {"Iron", "Stone", "Sulfur"},
    Tooltip = "Выберите руду для отображения"
})
Options.OreESPSelected:OnChanged(function()
    OreESPState.SelectedOres = Options.OreESPSelected.Value
end)

RenderGroupObjectESP:AddSlider("OreESPMaxPerOre", {
    Text = "Лимит на тип руды",
    Default = OreESPState.MaxPerOre,
    Min = 1,
    Max = 20,
    Rounding = 0,
    Tooltip = "Максимальное количество руды каждого типа"
})
Options.OreESPMaxPerOre:OnChanged(function()
    OreESPState.MaxPerOre = Options.OreESPMaxPerOre.Value
end)

-- UI для Hacks
local HacksGroup = Tabs.Hacks:AddLeftGroupbox("Movement Hacks")

-- Speedhack
HacksGroup:AddToggle("SpeedhackEnabled", {
    Text = "Speedhack",
    Default = SpeedhackState.Enabled,
    Tooltip = "Двигает тело игрока с заданной скоростью"
})
Toggles.SpeedhackEnabled:OnChanged(function()
    SpeedhackState.Enabled = Toggles.SpeedhackEnabled.Value
    Library:Notify("Speedhack " .. (SpeedhackState.Enabled and "включён" or "выключен"))
end)

HacksGroup:AddSlider("SpeedhackSpeed", {
    Text = "Скорость Speedhack",
    Default = SpeedhackState.Speed,
    Min = 20,
    Max = 80,
    Rounding = 0,
    Tooltip = "Скорость передвижения (20-80)"
})
Options.SpeedhackSpeed:OnChanged(function()
    SpeedhackState.Speed = Options.SpeedhackSpeed.Value
end)

HacksGroup:AddButton({
    Text = "Назначить клавишу Speedhack",
    Func = function()
        Library:Notify("Нажми клавишу для Speedhack (текущая: " .. (SpeedhackState.Bind and SpeedhackState.Bind.Name or "Нет") .. ")")
        local binding = true
        local connection
        connection = UserInputService.InputBegan:Connect(function(input)
            if binding and input.UserInputType == Enum.UserInputType.Keyboard then
                SpeedhackState.Bind = input.KeyCode
                Library:Notify("Клавиша Speedhack установлена: " .. input.KeyCode.Name)
                binding = false
                connection:Disconnect()
            end
        end)
    end,
    Tooltip = "Назначить клавишу для переключения Speedhack"
})

HacksGroup:AddButton({
    Text = "Удалить клавишу Speedhack",
    Func = function()
        SpeedhackState.Bind = nil
        Library:Notify("Клавиша Speedhack удалена")
    end,
    Tooltip = "Удаляет текущую клавишу Speedhack"
})

-- Bunny Hop
HacksGroup:AddToggle("BunnyHopEnabled", {
    Text = "Bunny Hop",
    Default = BunnyHopState.Enabled,
    Tooltip = "Позволяет прыгать без задержки"
})
Toggles.BunnyHopEnabled:OnChanged(function()
    BunnyHopState.Enabled = Toggles.BunnyHopEnabled.Value
    Library:Notify("Bunny Hop " .. (BunnyHopState.Enabled and "включён" or "выключен"))
end)

-- Force Speed
HacksGroup:AddToggle("ForceSpeedEnabled", {
    Text = "Force Speed",
    Default = ForceSpeedState.Enabled,
    Tooltip = "Устанавливает скорость 26 и позволяет свободно двигаться"
})
Toggles.ForceSpeedEnabled:OnChanged(function()
    ForceSpeedState.Enabled = Toggles.ForceSpeedEnabled.Value
    Library:Notify("Force Speed " .. (ForceSpeedState.Enabled and "включён" or "выключен"))
end)

-- Fly
HacksGroup:AddToggle("FlyEnabled", {
    Text = "Fly",
    Default = FlyState.Enabled,
    Tooltip = "Включает полёт с разными режимами"
})
Toggles.FlyEnabled:OnChanged(function()
    FlyState.Enabled = Toggles.FlyEnabled.Value
    Library:Notify("Fly " .. (FlyState.Enabled and "включён" or "выключен"))
end)

HacksGroup:AddDropdown("FlyMode", {
    Text = "Режим полёта",
    Default = FlyState.Mode,
    Values = FlyState.AvailableModes,
    Tooltip = "Выберите режим полёта"
})
Options.FlyMode:OnChanged(function()
    FlyState.Mode = Options.FlyMode.Value
    Library:Notify("Режим полёта изменён на " .. FlyState.Mode)
end)

HacksGroup:AddSlider("FlySpeed", {
    Text = "Скорость полёта",
    Default = FlyState.Speed,
    Min = 20,
    Max = 80,
    Rounding = 0,
    Tooltip = "Скорость для FreeFly и JumpFly (20-80)"
})
Options.FlySpeed:OnChanged(function()
    FlyState.Speed = Options.FlySpeed.Value
end)

-- Spider
HacksGroup:AddToggle("SpiderEnabled", {
    Text = "Spider",
    Default = SpiderState.Enabled,
    Tooltip = "Позволяет лазить по стенам"
})
Toggles.SpiderEnabled:OnChanged(function()
    SpiderState.Enabled = Toggles.SpiderEnabled.Value
    Library:Notify("Spider " .. (SpiderState.Enabled and "включён" or "выключен"))
end)

HacksGroup:AddSlider("SpiderSpeed", {
    Text = "Скорость Spider",
    Default = SpiderState.Speed,
    Min = 10,
    Max = 40,
    Rounding = 0,
    Tooltip = "Скорость подъёма по стенам (10-40)"
})
Options.SpiderSpeed:OnChanged(function()
    SpiderState.Speed = Options.SpiderSpeed.Value
end)

-- FreeCam
HacksGroup:AddToggle("FreeCamEnabled", {
    Text = "FreeCam",
    Default = FreeCamState.Enabled,
    Tooltip = "Свободная камера с видом от первого лица"
})
Toggles.FreeCamEnabled:OnChanged(function()
    FreeCamState.Enabled = Toggles.FreeCamEnabled.Value
    Library:Notify("FreeCam " .. (FreeCamState.Enabled and "включён" or "выключен"))
end)

HacksGroup:AddDropdown("FreeCamMode", {
    Text = "Режим FreeCam",
    Default = FreeCamState.Mode,
    Values = FreeCamState.AvailableModes,
    Tooltip = "Middle: Скорость 10; Button: Настраиваемая скорость"
})
Options.FreeCamMode:OnChanged(function()
    FreeCamState.Mode = Options.FreeCamMode.Value
    Library:Notify("Режим FreeCam изменён на " .. FreeCamState.Mode)
end)

HacksGroup:AddSlider("FreeCamSpeed", {
    Text = "Скорость FreeCam (Button)",
    Default = FreeCamState.Speed,
    Min = 20,
    Max = 100,
    Rounding = 0,
    Tooltip = "Скорость движения камеры для Button (20-100), Middle всегда 10"
})
Options.FreeCamSpeed:OnChanged(function()
    FreeCamState.Speed = Options.FreeCamSpeed.Value
end)

HacksGroup:AddButton({
    Text = "Delete Wall",
    Func = function()
        FreeCamState.DeleteWallEnabled = not FreeCamState.DeleteWallEnabled
        Library:Notify("Delete Wall " .. (FreeCamState.DeleteWallEnabled and "включён" or "выключен") .. " (Alt + ЛКМ)")
    end,
    Tooltip = "Включает удаление стен при зажатии Alt + ЛКМ"
})

-- UI для Manipulations
local ManipulationsGroup = Tabs.Hacks:AddRightGroupbox("Manipulations")

-- Visual Tool
ManipulationsGroup:AddDropdown("VisualToolSelected", {
    Text = "Выбрать предмет",
    Default = VisualToolState.SelectedTool,
    Values = VisualToolState.AvailableTools,
    Tooltip = "Выберите предмет для выдачи"
})
Options.VisualToolSelected:OnChanged(function()
    VisualToolState.SelectedTool = Options.VisualToolSelected.Value
end)

ManipulationsGroup:AddSlider("VisualToolAmount", {
    Text = "Количество",
    Default = VisualToolState.Amount,
    Min = 1,
    Max = 128,
    Rounding = 0,
    Tooltip = "Количество предметов (1-128)"
})
Options.VisualToolAmount:OnChanged(function()
    VisualToolState.Amount = Options.VisualToolAmount.Value
end)

ManipulationsGroup:AddButton({
    Text = "Выдать",
    Func = function()
        spawnTool(VisualToolState.SelectedTool, VisualToolState.Amount)
    end,
    Tooltip = "Выдать выбранный предмет в указанном количестве"
})

-- Show All Backpack
ManipulationsGroup:AddButton({
    Text = "Show All Backpack",
    Func = function()
        ShowBackpackState.WindowVisible = not ShowBackpackState.WindowVisible
        if ShowBackpackState.WindowVisible then
            showBackpackWindow()
        else
            hideBackpackWindow()
        end
    end,
    Tooltip = "Показать/скрыть список рюкзаков"
})

-- UI для Visuals
local VisualGroup = Tabs.Visual:AddLeftGroupbox("Visual Settings")

-- View Model
VisualGroup:AddToggle("ViewModelEnabled", {
    Text = "Включить View Model",
    Default = VisualState.ViewModelEnabled,
    Tooltip = "Включает/выключает View Model"
})
Toggles.ViewModelEnabled:OnChanged(function()
    VisualState.ViewModelEnabled = Toggles.ViewModelEnabled.Value
    Library:Notify("View Model " .. (VisualState.ViewModelEnabled and "включён" or "выключен"))
end)

VisualGroup:AddSlider("ViewModelFOV", {
    Text = "FOV View Model",
    Default = VisualState.FOV,
    Min = 70,
    Max = 120,
    Rounding = 0,
    Tooltip = "Настройка поля зрения для View Model"
})
Options.ViewModelFOV:OnChanged(function()
    VisualState.FOV = Options.ViewModelFOV.Value
end)

-- Jump Circle
VisualGroup:AddToggle("JumpCircleEnabled", {
    Text = "Включить Jump Circle",
    Default = VisualState.JumpCircleEnabled,
    Tooltip = "Включает/выключает круг при прыжке"
})
Toggles.JumpCircleEnabled:OnChanged(function()
    VisualState.JumpCircleEnabled = Toggles.JumpCircleEnabled.Value
    Library:Notify("Jump Circle " .. (VisualState.JumpCircleEnabled and "включён" or "выключен"))
end)

VisualGroup:AddSlider("CircleSpeed", {
    Text = "Скорость исчезания",
    Default = VisualState.CircleSpeed,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Tooltip = "Скорость исчезания круга (1-100)"
})
Options.CircleSpeed:OnChanged(function()
    VisualState.CircleSpeed = Options.CircleSpeed.Value
end)

VisualGroup:AddDropdown("CircleColor", {
    Text = "Цвет круга",
    Default = VisualState.CircleColor,
    Values = VisualState.AvailableColors,
    Tooltip = "Выберите цвет для Jump Circle"
})
Options.CircleColor:OnChanged(function()
    VisualState.CircleColor = Options.CircleColor.Value
end)

-- Titles
local TitlesGroup = Tabs.Visual:AddRightGroupbox("Titles")

TitlesGroup:AddToggle("TitlesEnabled", {
    Text = "Включить Titles",
    Default = TitlesState.Enabled,
    Tooltip = "Включает/выключает отображение титулов"
})
Toggles.TitlesEnabled:OnChanged(function()
    TitlesState.Enabled = Toggles.TitlesEnabled.Value
    Library:Notify("Titles " .. (TitlesState.Enabled and "включены" or "выключены"))
end)

TitlesGroup:AddToggle("TitlesRGB", {
    Text = "RGB для Titles",
    Default = TitlesState.RGBEnabled,
    Tooltip = "Включает RGB-эффект для титулов"
})
Toggles.TitlesRGB:OnChanged(function()
    TitlesState.RGBEnabled = Toggles.TitlesRGB.Value
end)

-- Staff Online
local StaffGroup = Tabs.Visual:AddRightGroupbox("Helper")

StaffGroup:AddToggle("StaffOnlineEnabled", {
    Text = "Staff Online",
    Default = StaffOnlineState.Enabled,
    Tooltip = "Показывает, онлайн ли игроки из белого списка"
})
Toggles.StaffOnlineEnabled:OnChanged(function()
    StaffOnlineState.Enabled = Toggles.StaffOnlineEnabled.Value
    Library:Notify("Staff Online " .. (StaffOnlineState.Enabled and "включён" or "выключен"))
end)

StaffGroup:AddToggle("FullbrightEnabled", {
    Text = "Fullbright",
    Default = FullbrightState.Enabled,
    Tooltip = "Делает сцену яркой независимо от времени суток"
})
Toggles.FullbrightEnabled:OnChanged(function()
    FullbrightState.Enabled = Toggles.FullbrightEnabled.Value
    Library:Notify("Fullbright " .. (FullbrightState.Enabled and "включён" or "выключен"))
end)

StaffGroup:AddToggle("NoFogEnabled", {
    Text = "No Fog",
    Default = NoFogState.Enabled,
    Tooltip = "Убирает туман и облака"
})
Toggles.NoFogEnabled:OnChanged(function()
    NoFogState.Enabled = Toggles.NoFogEnabled.Value
    Library:Notify("No Fog " .. (NoFogState.Enabled and "включён" or "выключен"))
end)

StaffGroup:AddToggle("NoSkyEnabled", {
    Text = "No Sky",
    Default = NoSkyState.Enabled,
    Tooltip = "Полностью убирает Skybox"
})
Toggles.NoSkyEnabled:OnChanged(function()
    NoSkyState.Enabled = Toggles.NoSkyEnabled.Value
    Library:Notify("No Sky " .. (NoSkyState.Enabled and "включён" or "выключен"))
end)

local SkyGroup = Tabs.Visual:AddLeftGroupbox("Sky Settings")

SkyGroup:AddToggle("SkyEnabled", {
    Text = "Включить Cycles Sky",
    Default = SkyState.Enabled,
    Tooltip = "Включает/выключает настройку неба"
})
Toggles.SkyEnabled:OnChanged(function()
    SkyState.Enabled = Toggles.SkyEnabled.Value
    Library:Notify("Cycles Sky " .. (SkyState.Enabled and "включён" or "выключен"))
end)

SkyGroup:AddDropdown("SkyCycleMode", {
    Text = "Режим неба",
    Default = SkyState.CycleMode,
    Values = SkyState.AvailableCycles,
    Tooltip = "Выберите стиль облаков и неба"
})
Options.SkyCycleMode:OnChanged(function()
    SkyState.CycleMode = Options.SkyCycleMode.Value
    Library:Notify("Режим неба изменён на " .. SkyState.CycleMode)
end)

local CrosshairGroup = Tabs.Visual:AddRightGroupbox("Crosshair")

CrosshairGroup:AddToggle("CrosshairEnabled", {
    Text = "Включить Crosshair",
    Default = CrosshairState.Enabled,
    Tooltip = "Включает/выключает прицел"
})
Toggles.CrosshairEnabled:OnChanged(function()
    CrosshairState.Enabled = Toggles.CrosshairEnabled.Value
    Library:Notify("Crosshair " .. (CrosshairState.Enabled and "включён" or "выключен"))
end)

CrosshairGroup:AddDropdown("CrosshairType", {
    Text = "Тип прицела",
    Default = CrosshairState.Type,
    Values = CrosshairState.AvailableTypes,
    Tooltip = "Выберите стиль прицела"
})
Options.CrosshairType:OnChanged(function()
    CrosshairState.Type = Options.CrosshairType.Value
end)

CrosshairGroup:AddToggle("CrosshairRGB", {
    Text = "RGB Crosshair",
    Default = CrosshairState.RGBEnabled,
    Tooltip = "Включает RGB-эффект для прицела"
})
Toggles.CrosshairRGB:OnChanged(function()
    CrosshairState.RGBEnabled = Toggles.CrosshairRGB.Value
end)

CrosshairGroup:AddToggle("CrosshairSpin", {
    Text = "Вращение Crosshair",
    Default = CrosshairState.SpinEnabled,
    Tooltip = "Включает вращение прицела"
})
Toggles.CrosshairSpin:OnChanged(function()
    CrosshairState.SpinEnabled = Toggles.CrosshairSpin.Value
end)

CrosshairGroup:AddSlider("CrosshairSpinSpeed", {
    Text = "Скорость вращения",
    Default = CrosshairState.SpinSpeed,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Tooltip = "Настройка скорости вращения прицела"
})
Options.CrosshairSpinSpeed:OnChanged(function()
    CrosshairState.SpinSpeed = Options.CrosshairSpinSpeed.Value
end)

-- Функция создания круга при приземлении
local function createJumpCircle(character)
    if not VisualState.JumpCircleEnabled or not character then return end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end

    local circle = Instance.new("Part")
    circle.Shape = Enum.PartType.Cylinder
    circle.Size = Vector3.new(0.1, 5, 5)
    circle.Position = Vector3.new(rootPart.Position.X, rootPart.Position.Y - rootPart.Size.Y / 2, rootPart.Position.Z)
    circle.CFrame = circle.CFrame * CFrame.Angles(math.rad(0), 0, 100)
    circle.Anchored = true
    circle.CanCollide = false
    circle.Material = Enum.Material.Neon
    circle.Transparency = 0.3
    circle.Parent = workspace

    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 1, 0)
    billboard.AlwaysOnTop = true
    billboard.Adornee = circle
    billboard.Parent = circle

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "simfoniaHUB"
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextScaled = true
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.Parent = billboard

    local duration = VisualState.CircleSpeed * 0.1
    local startTime = tick()
    local initialSize = circle.Size

    local connection
    connection = RunService.Heartbeat:Connect(function()
        local elapsed = tick() - startTime
        local progress = elapsed / duration
        if progress >= 1 then
            circle:Destroy()
            if connection then connection:Disconnect() end
            return
        end

        circle.Size = Vector3.new(0.1, initialSize.Y * (1 - progress), initialSize.Z * (1 - progress))

        if VisualState.CircleColor == "BlueFade" then
            local b = math.sin(tick() * 2) * 127 + 128
            circle.Color = Color3.fromRGB(0, 191, b)
        elseif VisualState.CircleColor == "RGBBlue" then
            local b = math.sin(tick() * 2) * 127 + 128
            circle.Color = Color3.fromRGB(0, 0, b)
        elseif VisualState.CircleColor == "RGB" then
            local r = math.sin(tick() * 2) * 127 + 128
            local g = math.sin(tick() * 2 + 2) * 127 + 128
            local b = math.sin(tick() * 2 + 4) * 127 + 128
            circle.Color = Color3.fromRGB(r, g, b)
        end
    end)
end

-- Функция обновления View Model
local function updateViewModel()
    if VisualState.ViewModelEnabled then
        camera.FieldOfView = VisualState.FOV
    else
        camera.FieldOfView = defaultFOV
    end
end

-- Функция обновления Jump Circle
local function updateJumpCircle()
    local character = LocalPlayer.Character
    if not character or not VisualState.JumpCircleEnabled then return end

    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end

    local currentState = humanoid:GetState()
    if lastState == Enum.HumanoidStateType.Freefall and currentState == Enum.HumanoidStateType.Landed then
        createJumpCircle(character)
    end
    lastState = currentState
end

-- Функция создания титула
local function createTitle()
    local title = Drawing.new("Text")
    title.Text = "simfoniaHUB"
    title.Color = Color3.fromRGB(255, 255, 255)
    title.Size = math.random(20, 40)
    title.Position = Vector2.new(math.random(0, camera.ViewportSize.X), math.random(0, camera.ViewportSize.Y))
    title.Transparency = 0.7
    title.Visible = false
    local velocity = Vector2.new(math.random(-50, 50) / 10, math.random(-50, 50) / 10)
    return { Object = title, Velocity = velocity }
end

-- Функция обновления Titles
local function updateTitles(deltaTime)
    if not TitlesState.Enabled then
        for _, title in pairs(titles) do
            title.Object.Visible = false
        end
        return
    end

    while #titles < 10 do
        table.insert(titles, createTitle())
    end

    if TitlesState.RGBEnabled then
        rgbTime = rgbTime + deltaTime
        local r = math.sin(rgbTime * 2) * 127 + 128
        local g = math.sin(rgbTime * 2 + 2) * 127 + 128
        local b = math.sin(rgbTime * 2 + 4) * 127 + 128
        local rgbColor = Color3.fromRGB(r, g, b)
        for _, title in pairs(titles) do
            title.Object.Color = rgbColor
        end
    else
        for _, title in pairs(titles) do
            title.Object.Color = Color3.fromRGB(255, 255, 255)
        end
    end

    for _, title in pairs(titles) do
        title.Object.Visible = true
        local newPos = title.Object.Position + title.Velocity
        local screenWidth = camera.ViewportSize.X
        local screenHeight = camera.ViewportSize.Y

        if newPos.X < 0 or newPos.X > screenWidth then
            title.Velocity = Vector2.new(-title.Velocity.X, title.Velocity.Y)
            newPos = Vector2.new(math.clamp(newPos.X, 0, screenWidth), newPos.Y)
        end
        if newPos.Y < 0 or newPos.Y > screenHeight then
            title.Velocity = Vector2.new(title.Velocity.X, -title.Velocity.Y)
            newPos = Vector2.new(newPos.X, math.clamp(newPos.Y, 0, screenHeight))
        end
        title.Object.Position = newPos
    end
end

-- Функция создания Staff Online меню
local function createStaffMenu()
    if staffFrame then return end

    staffFrame = Instance.new("Frame")
    staffFrame.Size = UDim2.new(0, 100, 0, 300)
    staffFrame.Position = UDim2.new(0, 50, 0, 50)
    staffFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    staffFrame.BorderSizePixel = 0
    staffFrame.Parent = game.CoreGui:FindFirstChild("ScreenGui") or Instance.new("ScreenGui", game.CoreGui)

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 20)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "Staff Online"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextScaled = true
    titleLabel.Parent = staffFrame

    for i, name in pairs(StaffOnlineState.Whitelist) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0, 20 + (i - 1) * 20)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextScaled = true
        label.Parent = staffFrame
        staffLabels[name] = label
    end

    staffFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragOffset = Vector2.new(input.Position.X - staffFrame.Position.X.Offset, input.Position.Y - staffFrame.Position.Y.Offset)
        end
    end)

    staffFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    local UserInputService = game:GetService("UserInputService")
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            staffFrame.Position = UDim2.new(0, input.Position.X - dragOffset.X, 0, input.Position.Y - dragOffset.Y)
        end
    end)
end

-- Функция обновления Staff Online
local function updateStaffMenu()
    if not StaffOnlineState.Enabled then
        if staffFrame then
            staffFrame.Visible = false
        end
        return
    end

    if not staffFrame then
        createStaffMenu()
    end

    staffFrame.Visible = true

    local currentPlayers = {}
    for _, player in pairs(Players:GetPlayers()) do
        currentPlayers[player.Name] = true
    end

    for name, label in pairs(staffLabels) do
        if currentPlayers[name] then
            label.TextColor3 = Color3.fromRGB(0, 255, 0)
        else
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
    end
end

-- Инициализация Jump Circle
LocalPlayer.CharacterAdded:Connect(function(character)
    local humanoid = character:WaitForChild("Humanoid")
    lastState = humanoid:GetState()
    updateJumpCircle()
end)

-- Функция Fullbright
local Lighting = game:GetService("Lighting")
local defaultBrightness = Lighting.Brightness
local defaultFogEnd = Lighting.FogEnd

local function updateFullbright()
    if FullbrightState.Enabled then
        Lighting.Brightness = 2
        Lighting.FogEnd = 100000
        Lighting.ClockTime = 12 -- Полдень
    else
        Lighting.Brightness = defaultBrightness
        Lighting.FogEnd = defaultFogEnd
        -- Восстановление времени суток не делаем, так как это может быть изменено игрой
    end
end

-- Сначала определим updateSkyCycle
local function updateSkyCycle()
    local sky = Lighting:FindFirstChildOfClass("Sky")
    if NoSkyState.Enabled then
        if sky then sky:Destroy() end
        return
    end
    if not sky then
        sky = Instance.new("Sky", Lighting)
    end

    if SkyState.Enabled then
        if SkyState.CycleMode == "Realistic" then
            sky.SkyboxBk = "rbxassetid://600830446"
            sky.SkyboxDn = "rbxassetid://600831635"
            sky.SkyboxFt = "rbxassetid://600832720"
            sky.SkyboxLf = "rbxassetid://600833862"
            sky.SkyboxRt = "rbxassetid://600835007"
            sky.SkyboxUp = "rbxassetid://600836181"
        elseif SkyState.CycleMode == "Light" then
            sky.SkyboxBk = "rbxassetid://1012890"
            sky.SkyboxDn = "rbxassetid://1012891"
            sky.SkyboxFt = "rbxassetid://1012889"
            sky.SkyboxLf = "rbxassetid://1012887"
            sky.SkyboxRt = "rbxassetid://1012888"
            sky.SkyboxUp = "rbxassetid://1012892"
        elseif SkyState.CycleMode == "DeepNight" then
            sky.SkyboxBk = "rbxassetid://151165174"
            sky.SkyboxDn = "rbxassetid://151165191"
            sky.SkyboxFt = "rbxassetid://151165206"
            sky.SkyboxLf = "rbxassetid://151165223"
            sky.SkyboxRt = "rbxassetid://151165245"
            sky.SkyboxUp = "rbxassetid://151165264"
        end
    end
end

-- Затем updateNoSky
local function updateNoSky()
    local sky = Lighting:FindFirstChildOfClass("Sky")
    if NoSkyState.Enabled then
        if sky then
            sky:Destroy()
        end
    else
        if not sky then
            sky = Instance.new("Sky", Lighting)
        end
        updateSkyCycle() -- Теперь это безопасно
    end
end

-- Функция No Fog (для полноты)
local function updateNoFog()
    if NoFogState.Enabled then
        Lighting.FogEnd = 100000
        Lighting.FogStart = 100000
        local sky = Lighting:FindFirstChildOfClass("Sky")
        if sky then
            sky.CelestialBodiesShown = false
        end
    else
        Lighting.FogEnd = defaultFogEnd
        Lighting.FogStart = 0
        local sky = Lighting:FindFirstChildOfClass("Sky")
        if sky then
            sky.CelestialBodiesShown = true
        end
    end
end

-- Функция Crosshair
local crosshairParts = {}
local function createCrosshair()
    for _, part in pairs(crosshairParts) do
        part:Remove()
    end
    crosshairParts = {}

    if not CrosshairState.Enabled then return end

    local centerX, centerY = camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2

    if CrosshairState.Type == "DotCircle" then
        local circle = Drawing.new("Circle")
        circle.Radius = 10
        circle.Position = Vector2.new(centerX, centerY)
        circle.Thickness = 2
        circle.Color = Color3.fromRGB(255, 255, 255)
        circle.Filled = false
        circle.Visible = true
        table.insert(crosshairParts, circle)

        local dot = Drawing.new("Circle")
        dot.Radius = 2
        dot.Position = Vector2.new(centerX, centerY)
        dot.Color = Color3.fromRGB(255, 255, 255)
        dot.Filled = true
        dot.Visible = true
        table.insert(crosshairParts, dot)
    elseif CrosshairState.Type == "Cross" then
        local line1 = Drawing.new("Line")
        line1.From = Vector2.new(centerX, centerY - 10)
        line1.To = Vector2.new(centerX, centerY + 10)
        line1.Thickness = 2
        line1.Color = Color3.fromRGB(255, 255, 255)
        line1.Visible = true
        table.insert(crosshairParts, line1)

        local line2 = Drawing.new("Line")
        line2.From = Vector2.new(centerX - 10, centerY)
        line2.To = Vector2.new(centerX + 10, centerY)
        line2.Thickness = 2
        line2.Color = Color3.fromRGB(255, 255, 255)
        line2.Visible = true
        table.insert(crosshairParts, line2)
    end
end

local rotationAngle = 0
local function updateCrosshair(deltaTime)
    if not CrosshairState.Enabled then
        for _, part in pairs(crosshairParts) do
            part.Visible = false
        end
        return
    end

    if #crosshairParts == 0 then
        createCrosshair()
    end

    for _, part in pairs(crosshairParts) do
        part.Visible = true
    end

    if CrosshairState.RGBEnabled then
        local r = math.sin(tick() * 2) * 127 + 128
        local g = math.sin(tick() * 2 + 2) * 127 + 128
        local b = math.sin(tick() * 2 + 4) * 127 + 128
        for _, part in pairs(crosshairParts) do
            part.Color = Color3.fromRGB(r, g, b)
        end
    else
        for _, part in pairs(crosshairParts) do
            part.Color = Color3.fromRGB(255, 255, 255)
        end
    end

    if CrosshairState.SpinEnabled and CrosshairState.Type == "Cross" then
        rotationAngle = rotationAngle + (CrosshairState.SpinSpeed * deltaTime)
        local centerX, centerY = camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2
        local cosAngle = math.cos(rotationAngle)
        local sinAngle = math.sin(rotationAngle)

        local line1 = crosshairParts[1]
        local line2 = crosshairParts[2]

        line1.From = Vector2.new(centerX - 10 * cosAngle, centerY - 10 * sinAngle)
        line1.To = Vector2.new(centerX + 10 * cosAngle, centerY + 10 * sinAngle)
        line2.From = Vector2.new(centerX + 10 * sinAngle, centerY - 10 * cosAngle)
        line2.To = Vector2.new(centerX - 10 * sinAngle, centerY + 10 * cosAngle)
    end
end

-- Обновление при изменении настроек Crosshair
Toggles.CrosshairEnabled:OnChanged(function()
    CrosshairState.Enabled = Toggles.CrosshairEnabled.Value
    createCrosshair()
end)
Options.CrosshairType:OnChanged(function()
    CrosshairState.Type = Options.CrosshairType.Value
    createCrosshair()
end)

-- Speedhack
local UserInputService = game:GetService("UserInputService")
local function updateSpeedhack()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local humanoidRootPart = character.HumanoidRootPart

    if SpeedhackState.Enabled then
        local moveDirection = Vector3.new()
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end

        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
            humanoidRootPart.Velocity = Vector3.new(
                moveDirection.X * SpeedhackState.Speed,
                humanoidRootPart.Velocity.Y,
                moveDirection.Z * SpeedhackState.Speed
            )
        else
            humanoidRootPart.Velocity = Vector3.new(0, humanoidRootPart.Velocity.Y, 0)
        end
    end
end

-- Обработка бинда
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == SpeedhackState.Bind then
        SpeedhackState.Enabled = not SpeedhackState.Enabled
        Toggles.SpeedhackEnabled:SetValue(SpeedhackState.Enabled)
        Library:Notify("Speedhack " .. (SpeedhackState.Enabled and "включён" or "выключен") .. " через бинд")
    end
end)

-- Bunny Hop
local function updateBunnyHop()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Humanoid") then return end
    local humanoid = character.Humanoid

    if BunnyHopState.Enabled then
        if humanoid:GetState() == Enum.HumanoidStateType.Landed or humanoid:GetState() == Enum.HumanoidStateType.Running then
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                humanoid.Jump = true
            end
        end
    end
end

-- Force Speed
local defaultWalkSpeed = 16 -- Стандартная скорость ходьбы в Roblox
local function updateForceSpeed()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("Humanoid") then return end
    local humanoid = character.Humanoid

    if ForceSpeedState.Enabled then
        humanoid.WalkSpeed = ForceSpeedState.Speed
        -- Убираем ограничения направления движения
        humanoid.MoveDirection = humanoid.MoveDirection.Unit * ForceSpeedState.Speed
    else
        humanoid.WalkSpeed = defaultWalkSpeed
    end
end

-- Fly
local UserInputService = game:GetService("UserInputService")
local function updateFly()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then return end
    local humanoidRootPart = character.HumanoidRootPart
    local humanoid = character.Humanoid

    if FlyState.Enabled then
        humanoid.PlatformStand = true -- Отключаем стандартное движение

        if FlyState.Mode == "FreeFly" then
            local moveDirection = Vector3.new()
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + camera.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - camera.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - camera.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + camera.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection = moveDirection + Vector3.new(0, 1, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection = moveDirection - Vector3.new(0, 1, 0)
            end

            if moveDirection.Magnitude > 0 then
                moveDirection = moveDirection.Unit
                humanoidRootPart.Velocity = moveDirection * FlyState.Speed
            else
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            end

        elseif FlyState.Mode == "JumpFly" then
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) and humanoid:GetState() == Enum.HumanoidStateType.Jumping then
                humanoidRootPart.Velocity = Vector3.new(humanoidRootPart.Velocity.X, FlyState.Speed, humanoidRootPart.Velocity.Z)
                wait(0.1) -- Небольшая задержка для "платформы"
                humanoidRootPart.Velocity = Vector3.new(humanoidRootPart.Velocity.X, 0, humanoidRootPart.Velocity.Z)
            end

        elseif FlyState.Mode == "ClockFly" then
            humanoidRootPart.Velocity = Vector3.new(humanoidRootPart.Velocity.X, -5, humanoidRootPart.Velocity.Z) -- Медленное падение
        end
    else
        humanoid.PlatformStand = false -- Восстанавливаем стандартное движение
        humanoidRootPart.Velocity = Vector3.new(humanoidRootPart.Velocity.X, humanoidRootPart.Velocity.Y, humanoidRootPart.Velocity.Z)
    end
end

-- ClockFly: Подъём на клик
UserInputService.InputBegan:Connect(function(input)
    if FlyState.Enabled and FlyState.Mode == "ClockFly" and input.UserInputType == Enum.UserInputType.MouseButton1 then
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = character.HumanoidRootPart
            humanoidRootPart.Velocity = Vector3.new(humanoidRootPart.Velocity.X, 30, humanoidRootPart.Velocity.Z) -- Подъём на 30 studs
        end
    end
end)

-- Spider
local function updateSpider()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local humanoidRootPart = character.HumanoidRootPart

    if SpiderState.Enabled then
        local rayOrigin = humanoidRootPart.Position
        local rayDirection = humanoidRootPart.CFrame.LookVector * 2 -- Проверяем стену впереди
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

        if raycastResult then
            -- Если есть стена впереди, поднимаемся
            local moveDirection = Vector3.new(0, 1, 0)
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                humanoidRootPart.Velocity = moveDirection * SpiderState.Speed
            elseif UserInputService:IsKeyDown(Enum.KeyCode.S) then
                humanoidRootPart.Velocity = moveDirection * -SpiderState.Speed
            else
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0) -- Останавливаемся, если не двигаемся
            end
        else
            humanoidRootPart.Velocity = Vector3.new(humanoidRootPart.Velocity.X, humanoidRootPart.Velocity.Y, humanoidRootPart.Velocity.Z)
        end
    end
end

-- FreeCam
local UserInputService = game:GetService("UserInputService")
local originalCameraCFrame = nil
local originalCameraMode = nil
local function updateFreeCam(deltaTime)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") or not character:FindFirstChild("Humanoid") then return end
    local humanoidRootPart = character.HumanoidRootPart
    local humanoid = character.Humanoid

    if FreeCamState.Enabled then
        if not originalCameraCFrame then
            originalCameraCFrame = camera.CFrame
            originalCameraMode = LocalPlayer.CameraMode
        end

        camera.CameraType = Enum.CameraType.Scriptable
        humanoidRootPart.Anchored = true -- Фиксируем тело на месте
        LocalPlayer.CameraMode = Enum.CameraMode.LockFirstPerson -- Вид от первого лица

        local moveSpeed = (FreeCamState.Mode == "Middle") and 10 or FreeCamState.Speed
        local moveDirection = Vector3.new()
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            moveDirection = moveDirection + Vector3.new(0, 1, 0)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
            moveDirection = moveDirection - Vector3.new(0, 1, 0)
        end

        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit
            camera.CFrame = camera.CFrame + moveDirection * moveSpeed * deltaTime
        end

        -- Свободный поворот камеры мышкой
        local mouseDelta = UserInputService:GetMouseDelta()
        camera.CFrame = camera.CFrame * CFrame.Angles(math.rad(-mouseDelta.Y * 0.2), math.rad(-mouseDelta.X * 0.2), 0)
    else
        if originalCameraCFrame then
            camera.CFrame = originalCameraCFrame
            originalCameraCFrame = nil
        end
        if originalCameraMode then
            LocalPlayer.CameraMode = originalCameraMode
            originalCameraMode = nil
        end
        camera.CameraType = Enum.CameraType.Custom
        humanoidRootPart.Anchored = false
    end
end

-- Delete Wall
UserInputService.InputBegan:Connect(function(input)
    if FreeCamState.Enabled and FreeCamState.DeleteWallEnabled and input.UserInputType == Enum.UserInputType.MouseButton1 and UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) then
        local mouse = LocalPlayer:GetMouse()
        local ray = camera:ViewportPointToRay(mouse.X, mouse.Y)
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        local raycastResult = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)

        if raycastResult and raycastResult.Instance then
            raycastResult.Instance:Destroy()
            Library:Notify("Стена удалена")
        end
    end
end)

-- Aimbot объекты
local aimbotSnapline = Drawing.new("Line")
aimbotSnapline.Thickness = 2
aimbotSnapline.Color = Color3.fromRGB(255, 0, 0)
aimbotSnapline.Visible = false

local aimbotFovCircle = Drawing.new("Circle")
aimbotFovCircle.Thickness = 1
aimbotFovCircle.NumSides = 64
aimbotFovCircle.Radius = AimbotState.FOVSize
aimbotFovCircle.Filled = false
aimbotFovCircle.Visible = false

local aimbotActive = false

-- Функции для Aimbot
local function isInAimbotFOV(targetPos)
    if not AimbotState.FOVEnabled then return true end
    local mousePos = UserInputService:GetMouseLocation()
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
    return distance <= AimbotState.FOVSize
end

local function canSeeTarget(startPos, targetPos)
    if not AimbotState.SkipWall then return true end
    local ray = Ray.new(startPos, (targetPos - startPos).Unit * (targetPos - startPos).Magnitude)
    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
    return hit == nil or hit:IsDescendantOf(targetPos.Parent)
end

local function getAimbotTarget()
    local nearestTarget = nil
    local nearestDistance = AimbotState.FOVEnabled and math.huge or AimbotState.Radius
    local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            local targetPart = AimbotState.TargetPart == "Head" and player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and humanoid.Health > 0 and (not AimbotState.FOVEnabled or isInAimbotFOV(targetPart.Position)) then
                local distance = (rootPart.Position - targetPart.Position).Magnitude
                if (AimbotState.FOVEnabled and distance < nearestDistance) or (not AimbotState.FOVEnabled and distance <= AimbotState.Radius) then
                    if canSeeTarget(rootPart.Position, targetPart.Position) then
                        nearestDistance = distance
                        nearestTarget = targetPart
                    end
                end
            end
        end
    end
    return nearestTarget
end

local function updateAimbot()
    if not AimbotState.Enabled then
        aimbotSnapline.Visible = false
        aimbotFovCircle.Visible = false
        return
    end

    if AimbotState.BindType == "Mouse" then
        aimbotActive = UserInputService:IsMouseButtonPressed(AimbotState.MouseBind or Enum.UserInputType.MouseButton2)
    elseif AimbotState.BindType == "Key" then
        aimbotActive = UserInputService:IsKeyDown(AimbotState.KeyBind or Enum.KeyCode.Unknown)
    end

    local target = getAimbotTarget()

    if AimbotState.SnaplineEnabled and target then
        local screenPos, onScreen = camera:WorldToViewportPoint(target.Position)
        if onScreen then
            aimbotSnapline.From = UserInputService:GetMouseLocation()
            aimbotSnapline.To = Vector2.new(screenPos.X, screenPos.Y)
            aimbotSnapline.Visible = true
        else
            aimbotSnapline.Visible = false
        end
    else
        aimbotSnapline.Visible = false
    end

    if aimbotActive and target then
        local targetPosition = target.Position
        local cameraPosition = camera.CFrame.Position
        local direction = (targetPosition - cameraPosition).Unit
        local newCFrame = CFrame.new(cameraPosition, cameraPosition + direction)
        local lerpFactor = AimbotState.Smoothness / 100
        camera.CFrame = camera.CFrame:Lerp(newCFrame, lerpFactor)
    end

    -- RGB для FOV Circle
    local mousePos = UserInputService:GetMouseLocation()
    aimbotFovCircle.Position = mousePos
    aimbotFovCircle.Radius = AimbotState.FOVSize
    aimbotFovCircle.Visible = AimbotState.FOVEnabled
    if AimbotState.FOVEnabled then
        local r = math.sin(tick() * 2) * 127 + 128
        local g = math.sin(tick() * 2 + 2) * 127 + 128
        local b = math.sin(tick() * 2 + 4) * 127 + 128
        aimbotFovCircle.Color = Color3.fromRGB(r, g, b)
    end
end

-- Silent Aim объекты
local silentSnapline = Drawing.new("Line")
silentSnapline.Thickness = 2
silentSnapline.Color = Color3.fromRGB(0, 255, 255)
silentSnapline.Visible = false

local silentFovCircle = Drawing.new("Circle")
silentFovCircle.Thickness = 1
silentFovCircle.NumSides = 64
silentFovCircle.Radius = SilentAimState.FOVSize
silentFovCircle.Filled = false
silentFovCircle.Visible = false

local silentAimActive = false
local teleportedPlayer = nil

-- Функции для Silent Aim
local function isInSilentFOV(targetPos)
    if not SilentAimState.FOVEnabled then return true end
    local mousePos = UserInputService:GetMouseLocation()
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
    return distance <= SilentAimState.FOVSize
end

local function getSilentTarget()
    local nearestTarget = nil
    local nearestDistance = math.huge
    local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            local targetPart = SilentAimState.TargetPart == "Head" and player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and humanoid.Health > 0 and isInSilentFOV(targetPart.Position) then
                local distance = (rootPart.Position - targetPart.Position).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestTarget = { Player = player, Part = targetPart }
                end
            end
        end
    end
    return nearestTarget
end

local function updateSilentAim()
    if not SilentAimState.Enabled then
        silentSnapline.Visible = false
        silentFovCircle.Visible = false
        if teleportedPlayer then
            local rootPart = teleportedPlayer.Player.Character and teleportedPlayer.Player.Character:FindFirstChild("HumanoidRootPart")
            if rootPart and teleportedPlayer.OriginalCFrame then
                rootPart.CFrame = teleportedPlayer.OriginalCFrame
            end
            teleportedPlayer = nil
        end
        return
    end

    local target = getSilentTarget()
    local wasActive = silentAimActive
    silentAimActive = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) or 
                      (SilentAimState.KeyBind and UserInputService:IsKeyDown(SilentAimState.KeyBind)) or 
                      (SilentAimState.MouseBind and UserInputService:IsMouseButtonPressed(SilentAimState.MouseBind))

    if SilentAimState.SnaplineEnabled and target then
        local screenPos, onScreen = camera:WorldToViewportPoint(target.Part.Position)
        if onScreen then
            silentSnapline.From = UserInputService:GetMouseLocation()
            silentSnapline.To = Vector2.new(screenPos.X, screenPos.Y)
            silentSnapline.Visible = true
        else
            silentSnapline.Visible = false
        end
    else
        silentSnapline.Visible = false
    end

    local mousePos = UserInputService:GetMouseLocation()
    silentFovCircle.Position = mousePos
    silentFovCircle.Radius = SilentAimState.FOVSize
    silentFovCircle.Visible = SilentAimState.FOVEnabled

    if silentAimActive and target then
        local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            if not teleportedPlayer or teleportedPlayer.Player ~= target.Player then
                teleportedPlayer = {
                    Player = target.Player,
                    Part = target.Part,
                    OriginalCFrame = target.Player.Character.HumanoidRootPart.CFrame
                }
            end

            local mouseRay = camera:ViewportPointToRay(mousePos.X, mousePos.Y)
            local targetPosition = mouseRay.Origin + mouseRay.Direction * 20
            local offset = target.Part.Position - target.Player.Character.HumanoidRootPart.Position
            target.Player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition - offset)
        end
    elseif wasActive and not silentAimActive and teleportedPlayer then
        local rootPart = teleportedPlayer.Player.Character and teleportedPlayer.Player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart and teleportedPlayer.OriginalCFrame then
            rootPart.CFrame = teleportedPlayer.OriginalCFrame
        end
        teleportedPlayer = nil
    end
end

-- Функции для Hitbox Expander
local function updateHitboxExpander()
    if not HitboxExpanderState.Enabled then
        for player, data in pairs(originalHitboxData) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = player.Character.HumanoidRootPart
                rootPart.Size = data.Size
                rootPart.Transparency = data.Transparency
            end
        end
        originalHitboxData = {}
        return
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            if not originalHitboxData[player] then
                originalHitboxData[player] = {
                    Size = rootPart.Size,
                    Transparency = rootPart.Transparency
                }
            end
            rootPart.Size = Vector3.new(HitboxExpanderState.Size, HitboxExpanderState.Size, HitboxExpanderState.Size)
            rootPart.Transparency = HitboxExpanderState.Transparency
        end
    end
end

-- Legit Reset
local function updateLegitReset()
    if not LegitResetState.Enabled then return end

    local isKeyPressed = LegitResetState.KeyBind and UserInputService:IsKeyDown(LegitResetState.KeyBind)
    local isMousePressed = LegitResetState.MouseBind and UserInputService:IsMouseButtonPressed(LegitResetState.MouseBind)

    if (isKeyPressed or isMousePressed) and LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Dead) -- Легитный ресет
            Library:Notify("Персонаж сброшен (Legit Reset)")
        end
    end
end

-- Применение X-Ray (вызывается один раз при изменении состояния)
local function applyXRay()
    if FPSState.XRayEnabled then
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and not obj:IsA("Terrain") then
                if not originalTextureData[obj] then
                    originalTextureData[obj] = obj.Transparency
                    obj.Transparency = FPSState.XRayTransparency
                end
            end
        end
    else
        -- Восстанавливаем прозрачность, если X-Ray выключен
        for obj, transparency in pairs(originalTextureData) do
            if obj and obj.Parent and obj:IsA("BasePart") then
                obj.Transparency = transparency
            end
        end
        originalTextureData = {}
    end
end

-- Применение Delete Texture (вызывается один раз при изменении состояния)
local function applyDeleteTexture()
    if FPSState.DeleteTextureEnabled then
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("Texture") or obj:IsA("Decal") then
                if not originalTextureData[obj] then
                    originalTextureData[obj] = true
                    obj.Transparency = 1 -- Удаляем текстуру (делаем невидимой)
                end
            end
        end
    else
        -- Восстанавливаем текстуры
        for obj, _ in pairs(originalTextureData) do
            if obj and obj.Parent then
                obj.Transparency = 0
            end
        end
        originalTextureData = {}
    end
end

-- FPS (Delete Texture, X-Ray, Exit Game)
local function updateFPS()
    -- Exit Game
    if FPSState.ExitGameEnabled then
        local isKeyPressed = FPSState.ExitGameKeyBind and UserInputService:IsKeyDown(FPSState.ExitGameKeyBind)
        local isMousePressed = FPSState.ExitGameMouseBind and UserInputService:IsMouseButtonPressed(FPSState.ExitGameMouseBind)
        if isKeyPressed or isMousePressed then
            -- Кик из игры
            LocalPlayer:Kick("Выход из игры через Exit Game")
            Library:Notify("Вы были кикнуты из игры")
        end
    end
end

-- Реакция на изменение X-Ray
Toggles.XRayEnabled:OnChanged(function()
    FPSState.XRayEnabled = Toggles.XRayEnabled.Value
    applyXRay()
    Library:Notify("X-Ray " .. (FPSState.XRayEnabled and "включён" or "выключен"))
end)

Options.XRayTransparency:OnChanged(function()
    FPSState.XRayTransparency = Options.XRayTransparency.Value
    if FPSState.XRayEnabled then
        applyXRay() -- Обновляем прозрачность, если X-Ray включён
    end
end)

-- Реакция на изменение Delete Texture
Toggles.DeleteTextureEnabled:OnChanged(function()
    FPSState.DeleteTextureEnabled = Toggles.DeleteTextureEnabled.Value
    applyDeleteTexture()
    Library:Notify("Delete Texture " .. (FPSState.DeleteTextureEnabled and "включён" or "выключен"))
end)

-- HWH (Twister)
local function updateHWH(deltaTime)
    -- Twister
    if HWHState.TwisterEnabled and LocalPlayer.Character then
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            -- Вращаем персонажа вокруг оси Y
            local rotationSpeed = HWHState.TwisterSpeed * deltaTime
            local currentCFrame = rootPart.CFrame
            rootPart.CFrame = currentCFrame * CFrame.Angles(0, math.rad(rotationSpeed), 0)
        end
    end
end

-- Обновляем цикл RenderStepped
RunService.RenderStepped:Connect(function(deltaTime)
    updateViewModel()
    updateJumpCircle()
    updateTitles(deltaTime)
    updateStaffMenu()
    updateFullbright()
    updateSkyCycle()
    updateCrosshair(deltaTime)
    updateNoFog()
    updateNoSky()
    updateSpeedhack()
    updateBunnyHop()
    updateForceSpeed()
    updateFly()
    updateSpider()
    updateAimbot()
    updateSilentAim()
    updateHitboxExpander()
    updateLegitReset()
    updateHWH(deltaTime)
    updateFPS()
end)

-- Visual Tool
local function spawnTool(toolName, amount)
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local humanoidRootPart = character.HumanoidRootPart

    if toolName == "5.56 Rifle ammo" then
        local tool = Instance.new("Tool")
        tool.Name = toolName
        tool.RequiresHandle = false

        local ammoProperty = Instance.new("IntValue")
        ammoProperty.Name = "Ammo"
        ammoProperty.Value = math.min(amount, 128) -- Ограничиваем до 128 для патронов
        ammoProperty.Parent = tool

        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if backpack then
            tool.Parent = backpack
            Library:Notify(toolName .. " (" .. ammoProperty.Value .. ") добавлен в Backpack")
        else
            tool.Parent = workspace
            tool.Position = humanoidRootPart.Position + humanoidRootPart.CFrame.LookVector * 5
            Library:Notify(toolName .. " (" .. ammoProperty.Value .. ") упал перед игроком")
        end
    else
        for i = 1, amount do
            local tool = Instance.new("Tool")
            tool.Name = toolName
            tool.RequiresHandle = false

            local backpack = LocalPlayer:FindFirstChild("Backpack")
            if backpack then
                tool.Parent = backpack
            else
                tool.Parent = workspace
                tool.Position = humanoidRootPart.Position + humanoidRootPart.CFrame.LookVector * 5 + Vector3.new(0, i * 0.5, 0) -- Смещение по высоте
            end
        end
        Library:Notify(toolName .. " (" .. amount .. ") " .. (LocalPlayer:FindFirstChild("Backpack") and "добавлен в Backpack" or "упал перед игроком"))
    end
end

-- Show All Backpack Window
local backpackFrame = nil
local backpackButtons = {}
local function showBackpackWindow()
    if backpackFrame then return end

    backpackFrame = Instance.new("Frame")
    backpackFrame.Size = UDim2.new(0, 200, 0, 300)
    backpackFrame.Position = UDim2.new(0.5, -100, 0.5, -150)
    backpackFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    backpackFrame.BorderSizePixel = 0
    backpackFrame.Parent = game.CoreGui:FindFirstChild("ScreenGui") or Instance.new("ScreenGui", game.CoreGui)

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 20)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "DeathBackpacks"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextScaled = true
    titleLabel.Parent = backpackFrame

    local backpacks = workspace:GetDescendants()
    local deathBackpacks = {}
    for _, obj in pairs(backpacks) do
        if obj.Name == "DeathBackpack" then
            table.insert(deathBackpacks, obj)
        end
    end

    for i, backpack in ipairs(deathBackpacks) do
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0.9, 0, 0, 30)
        button.Position = UDim2.new(0.05, 0, 0, 30 + (i - 1) * 35)
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        button.Text = "Backpack " .. i
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextScaled = true
        button.Parent = backpackFrame
        backpackButtons[button] = backpack

        button.MouseButton1Click:Connect(function()
            ShowBackpackState.SelectedBackpack = backpack
            for btn in pairs(backpackButtons) do
                btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
            end
            button.BackgroundColor3 = Color3.fromRGB(0, 255, 0) -- Подсветка выбранного
        end)
    end

    local teleportButton = Instance.new("TextButton")
    teleportButton.Size = UDim2.new(0.9, 0, 0, 30)
    teleportButton.Position = UDim2.new(0.05, 0, 1, -35)
    teleportButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    teleportButton.Text = "Teleport"
    teleportButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    teleportButton.TextScaled = true
    teleportButton.Parent = backpackFrame

    teleportButton.MouseButton1Click:Connect(function()
        if ShowBackpackState.SelectedBackpack then
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = CFrame.new(ShowBackpackState.SelectedBackpack.Position + Vector3.new(0, 5, 0))
                Library:Notify("Телепортация к DeathBackpack")
            end
        else
            Library:Notify("Выбери рюкзак для телепортации!")
        end
    end)
end

local function hideBackpackWindow()
    if backpackFrame then
        backpackFrame:Destroy()
        backpackFrame = nil
        backpackButtons = {}
        ShowBackpackState.SelectedBackpack = nil
    end
end

-- SIM AI
local function setupSIMAI()
    local TextChatService = game:GetService("TextChatService")
    local textChannels = TextChatService:FindFirstChild("TextChannels")
    if not textChannels then return end

    local rbxtsChannel = textChannels:FindFirstChild("RBXGeneral") or textChannels:FindFirstChild("RBXSystem")
    if not rbxtsChannel then return end

    local function onMessageReceived(message)
        if not SIMAIState.Enabled then return end
        if not message.TextSource or message.TextSource.UserId ~= LocalPlayer.UserId then return end -- Проверяем, что сообщение от нас

        local text = message.Text:lower()
        if text == "/hellps" then
            -- Отправляем список команд от SIM AI
            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
            local response = Instance.new("TextLabel")
            response.Size = UDim2.new(0, 400, 0, 50)
            response.Position = UDim2.new(0.5, -200, 0.5, -25)
            response.BackgroundTransparency = 0.5
            response.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            response.Text = "SIM AI: Список команд: /DEXv4, /INFyeld, /unhook"
            response.TextColor3 = Color3.fromRGB(128, 0, 128) -- Фиолетовый текст
            response.TextScaled = true
            response.Parent = screenGui
            task.spawn(function()
                task.wait(5)
                screenGui:Destroy()
            end)
        elseif text == "/dexv4" then
            -- Запускаем DEXv4
            pcall(function()
                loadstring(game:HttpGet('https://www.roblox.com/games/11433785951/Mason-Tech-Power-Core-Reopened', true))()
            end)
            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
            local response = Instance.new("TextLabel")
            response.Size = UDim2.new(0, 400, 0, 50)
            response.Position = UDim2.new(0.5, -200, 0.5, -25)
            response.BackgroundTransparency = 0.5
            response.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            response.Text = "SIM AI: DEXv4 запущен!"
            response.TextColor3 = Color3.fromRGB(128, 0, 128)
            response.TextScaled = true
            response.Parent = screenGui
            task.spawn(function()
                task.wait(3)
                screenGui:Destroy()
            end)
        elseif text == "/infyeld" then
            -- Запускаем Infinite Yield
            pcall(function()
                loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
            end)
            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
            local response = Instance.new("TextLabel")
            response.Size = UDim2.new(0, 400, 0, 50)
            response.Position = UDim2.new(0.5, -200, 0.5, -25)
            response.BackgroundTransparency = 0.5
            response.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            response.Text = "SIM AI: Infinite Yield запущен!"
            response.TextColor3 = Color3.fromRGB(128, 0, 128)
            response.TextScaled = true
            response.Parent = screenGui
            task.spawn(function()
                task.wait(3)
                response:Destroy()
            end)
        elseif text == "/unhook" then
            -- Выключаем все функции и чит-меню
            for _, toggle in pairs(Toggles) do
                toggle:SetValue(false)
            end
            Library:Unload() -- Закрываем чит-меню
            local screenGui = Instance.new("ScreenGui")
            screenGui.Parent = game:GetService("CoreGui")
            local response = Instance.new("TextLabel")
            response.Size = UDim2.new(0, 400, 0, 50)
            response.Position = UDim2.new(0.5, -200, 0.5, -25)
            response.BackgroundTransparency = 0.5
            response.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
            response.Text = "SIM AI: Все функции и чит-меню отключены."
            response.TextColor3 = Color3.fromRGB(128, 0, 128)
            response.TextScaled = true
            response.Parent = screenGui
            task.spawn(function()
                task.wait(3)
                screenGui:Destroy()
            end)
        end
    end

    -- Подписываемся на сообщения в чате через TextChatService
    rbxtsChannel.MessageReceived:Connect(onMessageReceived)
end

-- Инициализация SIM AI
setupSIMAI()

-- Логика ESP для игроков
local ESP = {}
local camera = workspace.CurrentCamera or workspace:WaitForChild("CurrentCamera")
local weaponList = {"Ak1", "C4", "Revolver", "Rocket Launcher", "Bow", "Thompson"}

local function getPlayerWeapon(character)
    if not character then return "None" end
    for _, tool in pairs(character:GetChildren()) do
        if tool:IsA("Tool") then
            for _, weapon in pairs(weaponList) do
                if tool.Name == weapon then
                    return weapon
                end
            end
        end
    end
    return "None"
end

local function createESP(player)
    if player == LocalPlayer then return end
    
    local function setupESP()
        local character = player.Character
        if not character then return end
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
        local humanoid = character:WaitForChild("Humanoid", 5)
        if not humanoidRootPart or not humanoid then
            Library:Notify("Не удалось найти HumanoidRootPart или Humanoid для " .. player.Name)
            return
        end

        if ESP[player] then
            if ESP[player].Box then ESP[player].Box:Remove() end
            if ESP[player].Text then ESP[player].Text:Remove() end
            ESP[player] = nil
        end

        local box = Drawing.new("Square")
        box.Thickness = 2
        box.Filled = false
        box.Color = ESPState.Color
        box.Visible = false

        local text = Drawing.new("Text")
        text.Size = 16
        text.Color = Color3.fromRGB(255, 255, 255)
        text.Visible = false

        ESP[player] = {Box = box, Text = text}

        local connection
        connection = RunService.RenderStepped:Connect(function()
            if not player.Character or not player.Character.Parent or not humanoidRootPart or not humanoid or humanoid.Health <= 0 then
                box.Visible = false
                text.Visible = false
                if connection then connection:Disconnect() end
                if ESP[player] then
                    if ESP[player].Box then ESP[player].Box:Remove() end
                    if ESP[player].Text then ESP[player].Text:Remove() end
                    ESP[player] = nil
                end
                return
            end

            if ESPState.Enabled then
                local rootPos, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    local size = character:GetExtentsSize() * 1.2
                    local topLeft = camera:WorldToViewportPoint(humanoidRootPart.Position + Vector3.new(size.X/2, size.Y/2, size.Z/2))
                    local bottomRight = camera:WorldToViewportPoint(humanoidRootPart.Position - Vector3.new(size.X/2, size.Y/2, size.Z/2))

                    if topLeft.Z > 0 and bottomRight.Z > 0 then
                        local width = math.abs(topLeft.X - bottomRight.X)
                        local height = math.abs(topLeft.Y - bottomRight.Y)
                        local centerX = (topLeft.X + bottomRight.X) / 2

                        box.Size = Vector2.new(width, height)
                        box.Position = Vector2.new(centerX - width / 2, topLeft.Y)
                        box.Color = ESPState.Color
                        box.Visible = true

                        local textString = ""
                        if ESPState.Name then
                            textString = textString .. player.Name .. "\n"
                        end
                        if ESPState.Studs then
                            local distance = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (humanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude) or 0
                            textString = textString .. math.floor(distance) .. " studs\n"
                        end
                        if ESPState.HP then
                            textString = textString .. math.floor(humanoid.Health) .. "/" .. humanoid.MaxHealth .. " HP\n"
                        end
                        if ESPState.WeaponEnabled then
                            local weapon = getPlayerWeapon(character)
                            textString = textString .. weapon
                        end

                        text.Text = textString
                        text.Position = Vector2.new(centerX - width / 2, topLeft.Y - 20)
                        text.Visible = textString ~= ""
                    else
                        box.Visible = false
                        text.Visible = false
                    end
                else
                    box.Visible = false
                    text.Visible = false
                end
            else
                box.Visible = false
                text.Visible = false
            end
        end)
    end

    if player.Character then
        spawn(function()
            local success, err = pcall(setupESP)
            if not success then
                Library:Notify("Ошибка при создании ESP для " .. player.Name .. ": " .. err)
            end
        end)
    end

    player.CharacterAdded:Connect(function()
        spawn(function()
            local success, err = pcall(setupESP)
            if not success then
                Library:Notify("Ошибка при повторном создании ESP для " .. player.Name .. ": " .. err)
            end
        end)
    end)
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        spawn(function()
            local success, err = pcall(createESP, player)
            if not success then
                Library:Notify("Ошибка при инициализации ESP для " .. player.Name .. ": " .. err)
            end
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        spawn(function()
            local success, err = pcall(createESP, player)
            if not success then
                Library:Notify("Ошибка при добавлении ESP для нового игрока " .. player.Name .. ": " .. err)
            end
        end)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if ESP[player] then
        if ESP[player].Box then ESP[player].Box:Remove() end
        if ESP[player].Text then ESP[player].Text:Remove() end
        ESP[player] = nil
    end
end)

-- Логика Object ESP
local ObjectESP = {}
local trackedRecyclerHelicopter = {}
local trackedCupboard = {}

local function getDistanceToPlayer(obj)
    local playerRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not playerRoot then return math.huge end
    local objRoot = obj:IsA("Model") and obj.PrimaryPart or obj
    if not objRoot then return math.huge end
    return (playerRoot.Position - objRoot.Position).Magnitude
end

local function createObjectESP(object)
    if ObjectESP[object] then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Adornee = object:IsA("Model") and object.PrimaryPart or object
    billboard.Size = UDim2.new(0, 100, 0, 20)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = game.CoreGui
    billboard.ExtentsOffset = Vector3.new(0, 0, 0)

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = object.Name
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextScaled = false
    textLabel.TextSize = 14
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = ObjectESPState.Color
    textLabel.Parent = billboard

    ObjectESP[object] = billboard
    if object.Name == "Cupboard" then
        table.insert(trackedCupboard, object)
    elseif object.Name == "Recycler" or object.Name == "Helicopter" then
        table.insert(trackedRecyclerHelicopter, object)
    end

    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not object.Parent or not ObjectESPState.Enabled or not ObjectESPState.SelectedObjects[object.Name] then
            billboard.Enabled = false
            if connection then
                connection:Disconnect()
            end
            if ObjectESP[object] then
                ObjectESP[object]:Destroy()
                ObjectESP[object] = nil
                if object.Name == "Cupboard" then
                    for i, trackedObj in ipairs(trackedCupboard) do
                        if trackedObj == object then
                            table.remove(trackedCupboard, i)
                            break
                        end
                    end
                elseif object.Name == "Recycler" or object.Name == "Helicopter" then
                    for i, trackedObj in ipairs(trackedRecyclerHelicopter) do
                        if trackedObj == object then
                            table.remove(trackedRecyclerHelicopter, i)
                            break
                        end
                    end
                end
            end
            return
        end
        billboard.Enabled = true
    end)
end

local function updateObjectESP()
    if not ObjectESPState.Enabled then
        for _, billboard in pairs(ObjectESP) do
            if billboard then billboard:Destroy() end
        end
        ObjectESP = {}
        trackedRecyclerHelicopter = {}
        trackedCupboard = {}
        return
    end

    local recyclerHelicopterObjects = {}
    local cupboardObjects = {}
    for _, obj in pairs(workspace:GetDescendants()) do
        if ObjectESPState.SelectedObjects[obj.Name] then
            if obj.Name == "Cupboard" then
                table.insert(cupboardObjects, obj)
            elseif obj.Name == "Recycler" or obj.Name == "Helicopter" then
                table.insert(recyclerHelicopterObjects, obj)
            end
        end
    end

    table.sort(recyclerHelicopterObjects, function(a, b)
        return getDistanceToPlayer(a) < getDistanceToPlayer(b)
    end)
    table.sort(cupboardObjects, function(a, b)
        return getDistanceToPlayer(a) < getDistanceToPlayer(b)
    end)

    for obj, billboard in pairs(ObjectESP) do
        local isInLimit = false
        if obj.Name == "Cupboard" then
            for i = 1, math.min(#cupboardObjects, ObjectESPState.MaxCupboard) do
                if cupboardObjects[i] == obj then
                    isInLimit = true
                    break
                end
            end
        elseif obj.Name == "Recycler" or obj.Name == "Helicopter" then
            for i = 1, math.min(#recyclerHelicopterObjects, ObjectESPState.MaxRecyclerHelicopter) do
                if recyclerHelicopterObjects[i] == obj then
                    isInLimit = true
                    break
                end
            end
        end
        if not isInLimit then
            if billboard then billboard:Destroy() end
            ObjectESP[obj] = nil
            if obj.Name == "Cupboard" then
                for i, trackedObj in ipairs(trackedCupboard) do
                    if trackedObj == obj then
                        table.remove(trackedCupboard, i)
                        break
                    end
                end
            elseif obj.Name == "Recycler" or obj.Name == "Helicopter" then
                for i, trackedObj in ipairs(trackedRecyclerHelicopter) do
                    if trackedObj == obj then
                        table.remove(trackedRecyclerHelicopter, i)
                        break
                    end
                end
            end
        end
    end

    for i = 1, math.min(#recyclerHelicopterObjects, ObjectESPState.MaxRecyclerHelicopter) do
        local obj = recyclerHelicopterObjects[i]
        if not ObjectESP[obj] then
            createObjectESP(obj)
        end
    end
    for i = 1, math.min(#cupboardObjects, ObjectESPState.MaxCupboard) do
        local obj = cupboardObjects[i]
        if not ObjectESP[obj] then
            createObjectESP(obj)
        end
    end
end

task.spawn(function()
    while true do
        if ObjectESPState.Enabled then
            updateObjectESP()
        end
        wait(2) -- 2 секунды для оптимизации
    end
end)

workspace.DescendantAdded:Connect(function(obj)
    if ObjectESPState.Enabled and ObjectESPState.SelectedObjects[obj.Name] then
        updateObjectESP()
    end
end)

-- Логика Ore ESP
local OreESP = {}
local trackedOres = {Iron = {}, Stone = {}, Sulfur = {}}
local trackedOreObjects = {} -- Кэш для руды

local function createOreESP(ore)
    if OreESP[ore] then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Adornee = ore:IsA("Model") and ore.PrimaryPart or ore
    billboard.Size = UDim2.new(0, 100, 0, 20)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = game.CoreGui
    billboard.ExtentsOffset = Vector3.new(0, 0, 0)

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = ore.Name
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.TextScaled = false
    textLabel.TextSize = 14
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = OreESPState.Color
    textLabel.Parent = billboard

    OreESP[ore] = billboard
    local oreType = ore.Name:lower() == "iron" and "Iron" or
                    ore.Name:lower() == "stone" and "Stone" or
                    ore.Name:lower() == "sulfur" and "Sulfur" or ore.Name
    table.insert(trackedOres[oreType], ore)

    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not ore.Parent or not OreESPState.Enabled or not OreESPState.SelectedOres[oreType] then
            billboard.Enabled = false
            if connection then
                connection:Disconnect()
            end
            if OreESP[ore] then
                OreESP[ore]:Destroy()
                OreESP[ore] = nil
                for i, trackedOre in ipairs(trackedOres[oreType]) do
                    if trackedOre == ore then
                        table.remove(trackedOres[oreType], i)
                        break
                    end
                end
            end
            return
        end
        billboard.Enabled = true
    end)
end

local function initializeOreTracking()
    trackedOreObjects = {}
    local oreFolder = workspace:FindFirstChild("ores")
    if oreFolder then
        for _, ore in pairs(oreFolder:GetChildren()) do
            local oreNameLower = ore.Name:lower()
            if oreNameLower == "iron" or oreNameLower == "stone" or oreNameLower == "sulfur" then
                trackedOreObjects[ore] = true
            end
        end
    end
end

local function updateOreESP()
    if not OreESPState.Enabled then
        for _, billboard in pairs(OreESP) do
            if billboard then billboard:Destroy() end
        end
        OreESP = {}
        trackedOres = {Iron = {}, Stone = {}, Sulfur = {}}
        return
    end

    local ironOres = {}
    local stoneOres = {}
    local sulfurOres = {}
    for ore in pairs(trackedOreObjects) do
        if ore.Parent then
            local oreType = ore.Name:lower() == "iron" and "Iron" or
                            ore.Name:lower() == "stone" and "Stone" or
                            ore.Name:lower() == "sulfur" and "Sulfur" or ore.Name
            if OreESPState.SelectedOres[oreType] then
                if oreType == "Iron" then
                    table.insert(ironOres, ore)
                elseif oreType == "Stone" then
                    table.insert(stoneOres, ore)
                elseif oreType == "Sulfur" then
                    table.insert(sulfurOres, ore)
                end
            end
        end
    end

    table.sort(ironOres, function(a, b)
        return getDistanceToPlayer(a) < getDistanceToPlayer(b)
    end)
    table.sort(stoneOres, function(a, b)
        return getDistanceToPlayer(a) < getDistanceToPlayer(b)
    end)
    table.sort(sulfurOres, function(a, b)
        return getDistanceToPlayer(a) < getDistanceToPlayer(b)
    end)

    for ore, billboard in pairs(OreESP) do
        local oreType = ore.Name:lower() == "iron" and "Iron" or
                        ore.Name:lower() == "stone" and "Stone" or
                        ore.Name:lower() == "sulfur" and "Sulfur" or ore.Name
        local isInLimit = false
        if oreType == "Iron" then
            for i = 1, math.min(#ironOres, OreESPState.MaxPerOre) do
                if ironOres[i] == ore then
                    isInLimit = true
                    break
                end
            end
        elseif oreType == "Stone" then
            for i = 1, math.min(#stoneOres, OreESPState.MaxPerOre) do
                if stoneOres[i] == ore then
                    isInLimit = true
                    break
                end
            end
        elseif oreType == "Sulfur" then
            for i = 1, math.min(#sulfurOres, OreESPState.MaxPerOre) do
                if sulfurOres[i] == ore then
                    isInLimit = true
                    break
                end
            end
        end
        if not isInLimit or not ore.Parent then
            if billboard then billboard:Destroy() end
            OreESP[ore] = nil
            for i, trackedOre in ipairs(trackedOres[oreType]) do
                if trackedOre == ore then
                    table.remove(trackedOres[oreType], i)
                    break
                end
            end
        end
    end

    for i = 1, math.min(#ironOres, OreESPState.MaxPerOre) do
        local ore = ironOres[i]
        if not OreESP[ore] then
            createOreESP(ore)
        end
    end
    for i = 1, math.min(#stoneOres, OreESPState.MaxPerOre) do
        local ore = stoneOres[i]
        if not OreESP[ore] then
            createOreESP(ore)
        end
    end
    for i = 1, math.min(#sulfurOres, OreESPState.MaxPerOre) do
        local ore = sulfurOres[i]
        if not OreESP[ore] then
            createOreESP(ore)
        end
    end
end

-- Инициализация и обновление Ore ESP
Toggles.OreESPEnabled:OnChanged(function()
    OreESPState.Enabled = Toggles.OreESPEnabled.Value
    Library:Notify("Ore ESP " .. (OreESPState.Enabled and "включён" or "выключен"))
    if OreESPState.Enabled then
        initializeOreTracking()
        updateOreESP()
    end
end)

Options.OreESPSelected:OnChanged(function()
    OreESPState.SelectedOres = Options.OreESPSelected.Value
    if OreESPState.Enabled then
        initializeOreTracking()
        updateOreESP()
    end
end)

task.spawn(function()
    while true do
        if OreESPState.Enabled then
            updateOreESP()
        end
        wait(2) -- Обновление каждые 2 секунды для оптимизации
    end
end)

local oreFolder = workspace:FindFirstChild("ores")
if oreFolder then
    oreFolder.ChildAdded:Connect(function(ore)
        local oreNameLower = ore.Name:lower()
        if OreESPState.SelectedOres[oreNameLower == "iron" and "Iron" or oreNameLower == "stone" and "Stone" or oreNameLower == "sulfur" and "Sulfur"] then
            trackedOreObjects[ore] = true
            if OreESPState.Enabled then
                updateOreESP()
            end
        end
    end)
    oreFolder.ChildRemoved:Connect(function(ore)
        if trackedOreObjects[ore] then
            trackedOreObjects[ore] = nil
            if OreESP[ore] then
                OreESP[ore]:Destroy()
                OreESP[ore] = nil
                local oreType = ore.Name:lower() == "iron" and "Iron" or
                                ore.Name:lower() == "stone" and "Stone" or
                                ore.Name:lower() == "sulfur" and "Sulfur" or ore.Name
                for i, trackedOre in ipairs(trackedOres[oreType]) do
                    if trackedOre == ore then
                        table.remove(trackedOres[oreType], i)
                        break
                    end
                end
            end
        end
    end)
end
