local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
local camera = workspace.CurrentCamera

-- Таблица для хранения GUI-элементов
local GuiElements = {
    ScreenGui = Instance.new("ScreenGui"),
    MainFrame = Instance.new("Frame"),
    TitleLabel = Instance.new("TextLabel"),
    CategoryButtons = {},
    CategoryFrames = {},
    UnhookButton = nil,
    Gradient = Instance.new("UIGradient")
}

-- Таблица для хранения настроек макета
local LayoutSettings = {
    MainFrame = {
        Size = UDim2.new(0, 500, 0, 600),
        Position = UDim2.new(0.5, -250, 0.5, -300),
        BackgroundColor3 = Color3.fromRGB(0, 0, 0),
        BorderColor3 = Color3.fromRGB(0, 170, 255),
        BorderSizePixel = 2,
        Visible = true
    },
    TitleLabel = {
        Size = UDim2.new(1, 0, 0, 30),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(0, 170, 255),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Text = "Simfonia hub (ROST) v1.9"
    },
    CategoryButton = {
        Size = UDim2.new(0, 100, 0, 30),
        BackgroundColor3 = Color3.fromRGB(30, 30, 30),
        TextColor3 = Color3.fromRGB(0, 170, 255),
        TextScaled = true,
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    },
    CategoryFrame = {
        Size = UDim2.new(1, -10, 0, 510),
        Position = UDim2.new(0, 5, 0, 80),
        BackgroundColor3 = Color3.fromRGB(50, 50, 50),
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255),
        Visible = false
    },
    Container = {
        Size = UDim2.new(0, 480, 0, 100),
        BackgroundColor3 = Color3.fromRGB(20, 20, 20),
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    },
    ContainerLabel = {
        Size = UDim2.new(1, 0, 0, 20),
        BackgroundColor3 = Color3.fromRGB(0, 100, 200),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        TextScaled = true
    },
    ToggleButton = {
        Size = UDim2.new(0, 100, 0, 25),
        BackgroundColor3 = Color3.fromRGB(30, 30, 30),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        TextScaled = true,
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    },
    CheckBox = {
        Size = UDim2.new(0, 100, 0, 20),
        BackgroundColor3 = Color3.fromRGB(30, 30, 30),
        TextColor3 = Color3.fromRGB(0, 170, 255),
        TextScaled = true,
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    },
    UnhookButton = {
        Size = UDim2.new(0, 100, 0, 30),
        Position = UDim2.new(0, 390, 0, 560),
        BackgroundColor3 = Color3.fromRGB(255, 0, 0),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        Text = "UNHOOK",
        TextScaled = true,
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(255, 255, 255)
    },
    ColorPickerButton = {
        Size = UDim2.new(0, 100, 0, 25),
        BackgroundColor3 = Color3.fromRGB(30, 30, 30),
        TextColor3 = Color3.fromRGB(255, 255, 255),
        TextScaled = true,
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    },
    ColorPickerFrame = {
        Size = UDim2.new(0, 150, 0, 150),
        BackgroundColor3 = Color3.fromRGB(40, 40, 40),
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255),
        Visible = false
    },
    SliderFrame = {
        Size = UDim2.new(0, 150, 0, 25),
        BackgroundColor3 = Color3.fromRGB(30, 30, 30),
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    },
    SliderBar = {
        Size = UDim2.new(0, 0, 1, 0),
        BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    },
    SliderKnob = {
        Size = UDim2.new(0, 10, 1, 0),
        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
        BorderSizePixel = 1,
        BorderColor3 = Color3.fromRGB(0, 170, 255)
    }
}

-- Таблица для хранения состояния
local CategoryState = {
    SelectedCategory = nil
}

local ESPState = {
    Enabled = false,
    Studs = false,
    Name = false,
    HP = false,
    Color = Color3.fromRGB(0, 255, 0),
    WeaponEnabled = false
}

local ObjectESPState = {
    Enabled = false,
    SelectedObjects = {},
    MaxObjects = 15, -- Увеличиваем до 15
    Color = Color3.fromRGB(0, 255, 0),
    NewObjectColor = Color3.fromRGB(0, 0, 255),
    NewObjectDuration = 20
}
-- Состояние Aimbot
local AimbotState = {
    Enabled = false,
    Radius = 50,          -- Радиус действия (20-100)
    Smoothness = 50,      -- Скорость наводки (1-100%)
    SkipWall = false,     -- Проверка стен
    FOVEnabled = false,   -- Включение/выключение FOV
    FOVSize = 200,        -- Размер FOV (1-700)
    SnaplineEnabled = false, -- Включение/выключение линии
    BindType = "Mouse",   -- Тип бинда: "Mouse" или "Key"
    MouseBind = Enum.UserInputType.MouseButton2, -- Правая кнопка мыши по умолчанию
    KeyBind = Enum.KeyCode.F,            -- Клавиша F по умолчанию
    TargetPart = "Head"   -- Часть тела для наводки: "Head" или "Body"
}

-- Состояние Silent Aim
local SilentAimState = {
    Enabled = false,
    FOVEnabled = false,   -- Включение/выключение FOV
    FOVSize = 200,        -- Размер FOV (1-700)
    SnaplineEnabled = false, -- Включение/выключение линии
    TargetPart = "Head"   -- Часть тела для телепортации: "Head" или "Body"
}

-- Состояние View Model
local ViewModelState = {
    Enabled = false,
    FOV = 70              -- FOV от 70 (дефолт) до 120 с шагом 5
}

-- Состояние Titles
local TitlesState = {
    Enabled = false,
    RGBEnabled = false -- Добавлено для управления RGB
}

-- Состояние Staff Online
local StaffOnlineState = {
    Enabled = false,
    Whitelist = { -- Белый список игроков (добавляйте ники сюда)
        "igarokmax",
        "33jeii2",
        "leon_vent4",
        "Alex_BossGr",
        ""
    }
}

-- Состояние Hitbox Expander
local HitboxExpanderState = {
    Enabled = false,
    Size = 1,             -- Размер хитбокса (1-8 studs)
    Transparency = 0.5    -- Прозрачность (0-1)
}

local SpeedState = {
    Enabled = false,
    Value = 20,
    DefaultSpeed = 16
}

local FlyState = {
    Enabled = false,
    WalkSpeed = 20,      -- Скорость ходьбы по воздуху (20-60)
    VerticalSpeed = 50,  -- Скорость вверх/вниз (20-100)
    Mode = "FreeFly",    -- "Platform" или "FreeFly"
    PlatformActive = false
}

-- Настройка ScreenGui
GuiElements.ScreenGui.Name = "CheatMenu"
GuiElements.ScreenGui.Parent = game:GetService("CoreGui")
GuiElements.ScreenGui.ResetOnSpawn = false

-- Настройка MainFrame
for prop, value in pairs(LayoutSettings.MainFrame) do
    GuiElements.MainFrame[prop] = value
end
GuiElements.MainFrame.Parent = GuiElements.ScreenGui

-- Добавление градиента
GuiElements.Gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 50, 100)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
})
GuiElements.Gradient.Parent = GuiElements.MainFrame

-- Настройка TitleLabel
for prop, value in pairs(LayoutSettings.TitleLabel) do
    GuiElements.TitleLabel[prop] = value
end
GuiElements.TitleLabel.TextScaled = true
GuiElements.TitleLabel.Parent = GuiElements.MainFrame

-- Создание категорий
local categories = {"Legit", "Render", "Visuals", "Misc"}
for i, category in ipairs(categories) do
    local button = Instance.new("TextButton")
    button.Name = category
    for prop, value in pairs(LayoutSettings.CategoryButton) do
        button[prop] = value
    end
    button.Position = UDim2.new((i - 1) * 0.25, 5, 0, 40)
    button.Text = "[" .. category:upper() .. "]"
    button.Parent = GuiElements.MainFrame
    GuiElements.CategoryButtons[category] = button

    local frame = Instance.new("Frame")
    frame.Name = category .. "Frame"
    for prop, value in pairs(LayoutSettings.CategoryFrame) do
        frame[prop] = value
    end
    frame.Parent = GuiElements.MainFrame
    GuiElements.CategoryFrames[category] = frame

    if category == "Render" then
    -- Существующий контейнер ESP
    local espContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        espContainer[prop] = value
    end
    espContainer.Position = UDim2.new(0, 0, 0, 0)
    espContainer.Parent = frame

    local espLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        espLabel[prop] = value
    end
    espLabel.Text = "Player ESP"
    espLabel.Parent = espContainer

    local espToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        espToggle[prop] = value
    end
    espToggle.Position = UDim2.new(0, 5, 0, 25)
    espToggle.Text = "ESP: OFF"
    espToggle.Parent = espContainer

    local colorPickerButton = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ColorPickerButton) do
        colorPickerButton[prop] = value
    end
    colorPickerButton.Position = UDim2.new(0, 110, 0, 25)
    colorPickerButton.Text = "Color"
    colorPickerButton.Parent = espContainer

    local colorPickerFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.ColorPickerFrame) do
        colorPickerFrame[prop] = value
    end
    colorPickerFrame.Position = UDim2.new(0, 110, 0, 55)
    colorPickerFrame.Parent = espContainer

    local colors = {
        Color3.fromRGB(255, 0, 0),
        Color3.fromRGB(0, 255, 0),
        Color3.fromRGB(0, 0, 255),
        Color3.fromRGB(255, 255, 0),
        Color3.fromRGB(255, 0, 255),
        Color3.fromRGB(0, 255, 255),
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(128, 0, 0),
        Color3.fromRGB(0, 128, 0),
        Color3.fromRGB(0, 0, 128)
    }

    for i, color in ipairs(colors) do
        local colorButton = Instance.new("TextButton")
        colorButton.Size = UDim2.new(0, 30, 0, 30)
        colorButton.Position = UDim2.new(0, ((i-1) % 5) * 35, 0, math.floor((i-1) / 5) * 35)
        colorButton.BackgroundColor3 = color
        colorButton.BorderSizePixel = 1
        colorButton.BorderColor3 = Color3.fromRGB(0, 170, 255)
        colorButton.Text = ""
        colorButton.Parent = colorPickerFrame
        
        colorButton.MouseButton1Click:Connect(function()
            ESPState.Color = color
            colorPickerFrame.Visible = false
        end)
    end

    local studsCheck = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.CheckBox) do
        studsCheck[prop] = value
    end
    studsCheck.Position = UDim2.new(0, 5, 0, 55)
    studsCheck.Text = "Studs: OFF"
    studsCheck.Parent = espContainer

    local nameCheck = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.CheckBox) do
        nameCheck[prop] = value
    end
    nameCheck.Position = UDim2.new(0, 110, 0, 55)
    nameCheck.Text = "Name: OFF"
    nameCheck.Parent = espContainer

    local hpCheck = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.CheckBox) do
        hpCheck[prop] = value
    end
    hpCheck.Position = UDim2.new(0, 215, 0, 55)
    hpCheck.Text = "HP: OFF"
    hpCheck.Parent = espContainer

    local weaponCheck = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.CheckBox) do
        weaponCheck[prop] = value
    end
    weaponCheck.Position = UDim2.new(0, 320, 0, 55)
    weaponCheck.Text = "Weapon: OFF"
    weaponCheck.Parent = espContainer

    espToggle.MouseButton1Click:Connect(function()
        ESPState.Enabled = not ESPState.Enabled
        espToggle.Text = "ESP: " .. (ESPState.Enabled and "ON" or "OFF")
    end)
    
    colorPickerButton.MouseButton1Click:Connect(function()
        colorPickerFrame.Visible = not colorPickerFrame.Visible
    end)

    studsCheck.MouseButton1Click:Connect(function()
        ESPState.Studs = not ESPState.Studs
        studsCheck.Text = "Studs: " .. (ESPState.Studs and "ON" or "OFF")
    end)
    nameCheck.MouseButton1Click:Connect(function()
        ESPState.Name = not ESPState.Name
        nameCheck.Text = "Name: " .. (ESPState.Name and "ON" or "OFF")
    end)
    hpCheck.MouseButton1Click:Connect(function()
        ESPState.HP = not ESPState.HP
        hpCheck.Text = "HP: " .. (ESPState.HP and "ON" or "OFF")
    end)
    weaponCheck.MouseButton1Click:Connect(function()
        ESPState.WeaponEnabled = not ESPState.WeaponEnabled
        weaponCheck.Text = "Weapon: " .. (ESPState.WeaponEnabled and "ON" or "OFF")
    end)

    -- Новый контейнер Object ESP
    local objectESPContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        objectESPContainer[prop] = value
    end
    objectESPContainer.Position = UDim2.new(0, 0, 0, 110) -- Ниже Player ESP
    objectESPContainer.Size = UDim2.new(0, 480, 0, 100)
    objectESPContainer.Parent = frame

    local objectESPLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        objectESPLabel[prop] = value
    end
    objectESPLabel.Text = "Object ESP"
    objectESPLabel.Parent = objectESPContainer

    local objectESPToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        objectESPToggle[prop] = value
    end
    objectESPToggle.Position = UDim2.new(0, 5, 0, 25)
    objectESPToggle.Text = "Object ESP: OFF"
    objectESPToggle.Parent = objectESPContainer

    -- Переключатели для объектов
    local objectOptions = {"Crate", "MilitaryCrate", "Helicopter", "Recycler"}
    for i, objName in ipairs(objectOptions) do
        local objCheck = Instance.new("TextButton")
        for prop, value in pairs(LayoutSettings.CheckBox) do
            objCheck[prop] = value
        end
        objCheck.Position = UDim2.new(0, 5 + (i - 1) * 105, 0, 55)
        objCheck.Text = objName .. ": OFF"
        objCheck.Parent = objectESPContainer

        objCheck.MouseButton1Click:Connect(function()
            if ObjectESPState.SelectedObjects[objName] then
                ObjectESPState.SelectedObjects[objName] = nil
                objCheck.Text = objName .. ": OFF"
            else
                if #ObjectESPState.SelectedObjects < ObjectESPState.MaxObjects then
                    ObjectESPState.SelectedObjects[objName] = true
                    objCheck.Text = objName .. ": ON"
                end
            end
        end)
    end

    objectESPToggle.MouseButton1Click:Connect(function()
        ObjectESPState.Enabled = not ObjectESPState.Enabled
        objectESPToggle.Text = "Object ESP: " .. (ObjectESPState.Enabled and "ON" or "OFF")
    end)
end

    if category == "Visuals" then
    -- View Model Container
    local viewModelContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        viewModelContainer[prop] = value
    end
    viewModelContainer.Size = UDim2.new(0, 480, 0, 100)
    viewModelContainer.Position = UDim2.new(0, 0, 0, 0)
    viewModelContainer.Parent = frame

    local viewModelLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        viewModelLabel[prop] = value
    end
    viewModelLabel.Text = "View Model"
    viewModelLabel.Parent = viewModelContainer

    local viewModelToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        viewModelToggle[prop] = value
    end
    viewModelToggle.Position = UDim2.new(0, 5, 0, 25)
    viewModelToggle.Text = "View Model: OFF"
    viewModelToggle.Parent = viewModelContainer

    local viewModelFovSliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        viewModelFovSliderFrame[prop] = value
    end
    viewModelFovSliderFrame.Position = UDim2.new(0, 5, 0, 55)
    viewModelFovSliderFrame.Parent = viewModelContainer

    local viewModelFovSliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        viewModelFovSliderBar[prop] = value
    end
    viewModelFovSliderBar.Parent = viewModelFovSliderFrame

    local viewModelFovSliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        viewModelFovSliderKnob[prop] = value
    end
    viewModelFovSliderKnob.Position = UDim2.new(0, ((ViewModelState.FOV - 70) / (120 - 70)) * 150 - 5, 0, 0)
    viewModelFovSliderKnob.Parent = viewModelFovSliderFrame

    local viewModelFovValueLabel = Instance.new("TextLabel")
    viewModelFovValueLabel.Size = UDim2.new(0, 50, 0, 20)
    viewModelFovValueLabel.Position = UDim2.new(0, 160, 0, 55)
    viewModelFovValueLabel.BackgroundTransparency = 1
    viewModelFovValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    viewModelFovValueLabel.TextScaled = true
    viewModelFovValueLabel.Text = tostring(ViewModelState.FOV)
    viewModelFovValueLabel.Parent = viewModelContainer

    -- Titles Container
    local titlesContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        titlesContainer[prop] = value
    end
    titlesContainer.Size = UDim2.new(0, 480, 0, 60)
    titlesContainer.Position = UDim2.new(0, 0, 0, 110)
    titlesContainer.Parent = frame

    local titlesLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        titlesLabel[prop] = value
    end
    titlesLabel.Text = "Titles"
    titlesLabel.Parent = titlesContainer

    local titlesToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        titlesToggle[prop] = value
    end
    titlesToggle.Position = UDim2.new(0, 5, 0, 25)
    titlesToggle.Text = "Titles: OFF"
    titlesToggle.Parent = titlesContainer

    local rgbToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        rgbToggle[prop] = value
    end
    rgbToggle.Position = UDim2.new(0, 110, 0, 25)
    rgbToggle.Text = "RGB: OFF"
    rgbToggle.Parent = titlesContainer

    -- Helper Container
    local helperContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        helperContainer[prop] = value
    end
    helperContainer.Size = UDim2.new(0, 480, 0, 60)
    helperContainer.Position = UDim2.new(0, 0, 0, 180) -- После Titles
    helperContainer.Parent = frame

    local helperLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        helperLabel[prop] = value
    end
    helperLabel.Text = "Helper"
    helperLabel.Parent = helperContainer

    local staffOnlineToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        staffOnlineToggle[prop] = value
    end
    staffOnlineToggle.Position = UDim2.new(0, 5, 0, 25)
    staffOnlineToggle.Text = "Staff Online: OFF"
    staffOnlineToggle.Parent = helperContainer

    -- Обработчики событий для View Model
    local viewModelFovDragging = false
    viewModelFovSliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            viewModelFovDragging = true
        end
    end)
    viewModelFovSliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            viewModelFovDragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if viewModelFovDragging then
                local mouseX = input.Position.X
                local sliderX = viewModelFovSliderFrame.AbsolutePosition.X
                local sliderWidth = viewModelFovSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                local newFov = 70 + math.floor((relativeX * (120 - 70)) / 5) * 5
                ViewModelState.FOV = newFov
                viewModelFovSliderKnob.Position = UDim2.new((newFov - 70) / (120 - 70), -5, 0, 0)
                viewModelFovSliderBar.Size = UDim2.new((newFov - 70) / (120 - 70), 0, 1, 0)
                viewModelFovValueLabel.Text = tostring(ViewModelState.FOV)
            end
        end
    end)

    viewModelToggle.MouseButton1Click:Connect(function()
        ViewModelState.Enabled = not ViewModelState.Enabled
        viewModelToggle.Text = "View Model: " .. (ViewModelState.Enabled and "ON" or "OFF")
    end)

    -- Обработчики тогглов (Titles)
    titlesToggle.MouseButton1Click:Connect(function()
        TitlesState.Enabled = not TitlesState.Enabled
        titlesToggle.Text = "Titles: " .. (TitlesState.Enabled and "ON" or "OFF")
    end)

    rgbToggle.MouseButton1Click:Connect(function()
        TitlesState.RGBEnabled = not TitlesState.RGBEnabled
        rgbToggle.Text = "RGB: " .. (TitlesState.RGBEnabled and "ON" or "OFF")
    end)

    -- Обработчик тоггла Staff Online
    staffOnlineToggle.MouseButton1Click:Connect(function()
        StaffOnlineState.Enabled = not StaffOnlineState.Enabled
        staffOnlineToggle.Text = "Staff Online: " .. (StaffOnlineState.Enabled and "ON" or "OFF")
    end)
end

    if category == "Legit" then
    -- Aimbot Container
    local aimbotContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        aimbotContainer[prop] = value
    end
    aimbotContainer.Size = UDim2.new(0, 480, 0, 210)
    aimbotContainer.Position = UDim2.new(0, 0, 0, 0)
    aimbotContainer.Parent = frame

    local aimbotLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        aimbotLabel[prop] = value
    end
    aimbotLabel.Text = "Aimbot"
    aimbotLabel.Parent = aimbotContainer

    local aimbotToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        aimbotToggle[prop] = value
    end
    aimbotToggle.Position = UDim2.new(0, 5, 0, 25)
    aimbotToggle.Text = "Aimbot: OFF"
    aimbotToggle.Parent = aimbotContainer

    -- Smoothness Slider (1-100%)
    local smoothnessSliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        smoothnessSliderFrame[prop] = value
    end
    smoothnessSliderFrame.Position = UDim2.new(0, 110, 0, 25)
    smoothnessSliderFrame.Parent = aimbotContainer

    local smoothnessSliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        smoothnessSliderBar[prop] = value
    end
    smoothnessSliderBar.Parent = smoothnessSliderFrame

    local smoothnessSliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        smoothnessSliderKnob[prop] = value
    end
    smoothnessSliderKnob.Position = UDim2.new(0, (AimbotState.Smoothness / 100) * 150 - 5, 0, 0)
    smoothnessSliderKnob.Parent = smoothnessSliderFrame

    local smoothnessValueLabel = Instance.new("TextLabel")
    smoothnessValueLabel.Size = UDim2.new(0, 50, 0, 20)
    smoothnessValueLabel.Position = UDim2.new(0, 265, 0, 25)
    smoothnessValueLabel.BackgroundTransparency = 1
    smoothnessValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    smoothnessValueLabel.TextScaled = true
    smoothnessValueLabel.Text = tostring(AimbotState.Smoothness) .. "%"
    smoothnessValueLabel.Parent = aimbotContainer

    -- Skip Wall Toggle
    local skipWallToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        skipWallToggle[prop] = value
    end
    skipWallToggle.Position = UDim2.new(0, 5, 0, 55)
    skipWallToggle.Text = "Skip Wall: OFF"
    skipWallToggle.Parent = aimbotContainer

    -- FOV Toggle (Aimbot)
    local aimbotFovToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        aimbotFovToggle[prop] = value
    end
    aimbotFovToggle.Position = UDim2.new(0, 110, 0, 55)
    aimbotFovToggle.Text = "FOV: OFF"
    aimbotFovToggle.Parent = aimbotContainer

    -- FOV Size Slider (Aimbot)
    local aimbotFovSizeSliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        aimbotFovSizeSliderFrame[prop] = value
    end
    aimbotFovSizeSliderFrame.Position = UDim2.new(0, 215, 0, 55)
    aimbotFovSizeSliderFrame.Parent = aimbotContainer

    local aimbotFovSizeSliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        aimbotFovSizeSliderBar[prop] = value
    end
    aimbotFovSizeSliderBar.Parent = aimbotFovSizeSliderFrame

    local aimbotFovSizeSliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        aimbotFovSizeSliderKnob[prop] = value
    end
    aimbotFovSizeSliderKnob.Position = UDim2.new(0, (AimbotState.FOVSize / 700) * 150 - 5, 0, 0)
    aimbotFovSizeSliderKnob.Parent = aimbotFovSizeSliderFrame

    local aimbotFovSizeValueLabel = Instance.new("TextLabel")
    aimbotFovSizeValueLabel.Size = UDim2.new(0, 50, 0, 20)
    aimbotFovSizeValueLabel.Position = UDim2.new(0, 370, 0, 55)
    aimbotFovSizeValueLabel.BackgroundTransparency = 1
    aimbotFovSizeValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    aimbotFovSizeValueLabel.TextScaled = true
    aimbotFovSizeValueLabel.Text = tostring(AimbotState.FOVSize)
    aimbotFovSizeValueLabel.Parent = aimbotContainer

    -- Snapline Toggle (Aimbot)
    local aimbotSnaplineToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        aimbotSnaplineToggle[prop] = value
    end
    aimbotSnaplineToggle.Position = UDim2.new(0, 5, 0, 85)
    aimbotSnaplineToggle.Text = "Snapline: OFF"
    aimbotSnaplineToggle.Parent = aimbotContainer

    -- Radius Slider (Aimbot)
    local radiusSliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        radiusSliderFrame[prop] = value
    end
    radiusSliderFrame.Position = UDim2.new(0, 110, 0, 85)
    radiusSliderFrame.Parent = aimbotContainer

    local radiusSliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        radiusSliderBar[prop] = value
    end
    radiusSliderBar.Parent = radiusSliderFrame

    local radiusSliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        radiusSliderKnob[prop] = value
    end
    radiusSliderKnob.Position = UDim2.new(0, ((AimbotState.Radius - 20) / (100 - 20)) * 150 - 5, 0, 0)
    radiusSliderKnob.Parent = radiusSliderFrame

    local radiusValueLabel = Instance.new("TextLabel")
    radiusValueLabel.Size = UDim2.new(0, 50, 0, 20)
    radiusValueLabel.Position = UDim2.new(0, 265, 0, 85)
    radiusValueLabel.BackgroundTransparency = 1
    radiusValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    radiusValueLabel.TextScaled = true
    radiusValueLabel.Text = tostring(AimbotState.Radius)
    radiusValueLabel.Parent = aimbotContainer

    -- Bind Type Toggle (Aimbot)
    local bindTypeToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        bindTypeToggle[prop] = value
    end
    bindTypeToggle.Position = UDim2.new(0, 5, 0, 115)
    bindTypeToggle.Text = "Bind: " .. AimbotState.BindType
    bindTypeToggle.Parent = aimbotContainer

    -- Bind Selection Button (Aimbot)
    local bindSelectButton = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        bindSelectButton[prop] = value
    end
    bindSelectButton.Position = UDim2.new(0, 110, 0, 115)
    bindSelectButton.Text = AimbotState.BindType == "Mouse" and "RMB" or AimbotState.KeyBind.Name
    bindSelectButton.Parent = aimbotContainer

    -- Target Part Toggle (Aimbot)
    local aimbotTargetPartToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        aimbotTargetPartToggle[prop] = value
    end
    aimbotTargetPartToggle.Position = UDim2.new(0, 5, 0, 145)
    aimbotTargetPartToggle.Text = "Target: " .. AimbotState.TargetPart
    aimbotTargetPartToggle.Parent = aimbotContainer

    -- Silent Aim Container
    local silentAimContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        silentAimContainer[prop] = value
    end
    silentAimContainer.Size = UDim2.new(0, 480, 0, 150)
    silentAimContainer.Position = UDim2.new(0, 0, 0, 220)
    silentAimContainer.Parent = frame

    local silentAimLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        silentAimLabel[prop] = value
    end
    silentAimLabel.Text = "Silent Aim"
    silentAimLabel.Parent = silentAimContainer

    local silentAimToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        silentAimToggle[prop] = value
    end
    silentAimToggle.Position = UDim2.new(0, 5, 0, 25)
    silentAimToggle.Text = "Silent Aim: OFF"
    silentAimToggle.Parent = silentAimContainer

    -- FOV Toggle (Silent Aim)
    local silentFovToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        silentFovToggle[prop] = value
    end
    silentFovToggle.Position = UDim2.new(0, 5, 0, 55)
    silentFovToggle.Text = "FOV: OFF"
    silentFovToggle.Parent = silentAimContainer

    -- FOV Size Slider (Silent Aim)
    local silentFovSizeSliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        silentFovSizeSliderFrame[prop] = value
    end
    silentFovSizeSliderFrame.Position = UDim2.new(0, 110, 0, 55)
    silentFovSizeSliderFrame.Parent = silentAimContainer

    local silentFovSizeSliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        silentFovSizeSliderBar[prop] = value
    end
    silentFovSizeSliderBar.Parent = silentFovSizeSliderFrame

    local silentFovSizeSliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        silentFovSizeSliderKnob[prop] = value
    end
    silentFovSizeSliderKnob.Position = UDim2.new(0, (SilentAimState.FOVSize / 700) * 150 - 5, 0, 0)
    silentFovSizeSliderKnob.Parent = silentFovSizeSliderFrame

    local silentFovSizeValueLabel = Instance.new("TextLabel")
    silentFovSizeValueLabel.Size = UDim2.new(0, 50, 0, 20)
    silentFovSizeValueLabel.Position = UDim2.new(0, 265, 0, 55)
    silentFovSizeValueLabel.BackgroundTransparency = 1
    silentFovSizeValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    silentFovSizeValueLabel.TextScaled = true
    silentFovSizeValueLabel.Text = tostring(SilentAimState.FOVSize)
    silentFovSizeValueLabel.Parent = silentAimContainer

    -- Snapline Toggle (Silent Aim)
    local silentSnaplineToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        silentSnaplineToggle[prop] = value
    end
    silentSnaplineToggle.Position = UDim2.new(0, 5, 0, 85)
    silentSnaplineToggle.Text = "Snapline: OFF"
    silentSnaplineToggle.Parent = silentAimContainer

    -- Target Part Toggle (Silent Aim)
    local silentTargetPartToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        silentTargetPartToggle[prop] = value
    end
    silentTargetPartToggle.Position = UDim2.new(0, 110, 0, 85)
    silentTargetPartToggle.Text = "Target: " .. SilentAimState.TargetPart
    silentTargetPartToggle.Parent = silentAimContainer

    -- Hitbox Expander Container
    local hitboxExpanderContainer = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.Container) do
        hitboxExpanderContainer[prop] = value
    end
    hitboxExpanderContainer.Size = UDim2.new(0, 480, 0, 150)
    hitboxExpanderContainer.Position = UDim2.new(0, 0, 0, 380) -- Ниже Silent Aim
    hitboxExpanderContainer.Parent = frame

    local hitboxExpanderLabel = Instance.new("TextLabel")
    for prop, value in pairs(LayoutSettings.ContainerLabel) do
        hitboxExpanderLabel[prop] = value
    end
    hitboxExpanderLabel.Text = "Hitbox Expander"
    hitboxExpanderLabel.Parent = hitboxExpanderContainer

    local hitboxExpanderToggle = Instance.new("TextButton")
    for prop, value in pairs(LayoutSettings.ToggleButton) do
        hitboxExpanderToggle[prop] = value
    end
    hitboxExpanderToggle.Position = UDim2.new(0, 5, 0, 25)
    hitboxExpanderToggle.Text = "Hitbox Expander: OFF"
    hitboxExpanderToggle.Parent = hitboxExpanderContainer

    -- Size Slider (1-8 studs)
    local hitboxSizeSliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        hitboxSizeSliderFrame[prop] = value
    end
    hitboxSizeSliderFrame.Position = UDim2.new(0, 5, 0, 55)
    hitboxSizeSliderFrame.Parent = hitboxExpanderContainer

    local hitboxSizeSliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        hitboxSizeSliderBar[prop] = value
    end
    hitboxSizeSliderBar.Parent = hitboxSizeSliderFrame

    local hitboxSizeSliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        hitboxSizeSliderKnob[prop] = value
    end
    hitboxSizeSliderKnob.Position = UDim2.new(0, ((HitboxExpanderState.Size - 1) / (8 - 1)) * 150 - 5, 0, 0)
    hitboxSizeSliderKnob.Parent = hitboxSizeSliderFrame

    local hitboxSizeValueLabel = Instance.new("TextLabel")
    hitboxSizeValueLabel.Size = UDim2.new(0, 50, 0, 20)
    hitboxSizeValueLabel.Position = UDim2.new(0, 160, 0, 55)
    hitboxSizeValueLabel.BackgroundTransparency = 1
    hitboxSizeValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    hitboxSizeValueLabel.TextScaled = true
    hitboxSizeValueLabel.Text = tostring(HitboxExpanderState.Size) .. " studs"
    hitboxSizeValueLabel.Parent = hitboxExpanderContainer

    -- Transparency Slider (0-1)
    local hitboxTransparencySliderFrame = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderFrame) do
        hitboxTransparencySliderFrame[prop] = value
    end
    hitboxTransparencySliderFrame.Position = UDim2.new(0, 5, 0, 85)
    hitboxTransparencySliderFrame.Parent = hitboxExpanderContainer

    local hitboxTransparencySliderBar = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderBar) do
        hitboxTransparencySliderBar[prop] = value
    end
    hitboxTransparencySliderBar.Parent = hitboxTransparencySliderFrame

    local hitboxTransparencySliderKnob = Instance.new("Frame")
    for prop, value in pairs(LayoutSettings.SliderKnob) do
        hitboxTransparencySliderKnob[prop] = value
    end
    hitboxTransparencySliderKnob.Position = UDim2.new(0, (HitboxExpanderState.Transparency) * 150 - 5, 0, 0)
    hitboxTransparencySliderKnob.Parent = hitboxTransparencySliderFrame

    local hitboxTransparencyValueLabel = Instance.new("TextLabel")
    hitboxTransparencyValueLabel.Size = UDim2.new(0, 50, 0, 20)
    hitboxTransparencyValueLabel.Position = UDim2.new(0, 160, 0, 85)
    hitboxTransparencyValueLabel.BackgroundTransparency = 1
    hitboxTransparencyValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    hitboxTransparencyValueLabel.TextScaled = true
    hitboxTransparencyValueLabel.Text = tostring(HitboxExpanderState.Transparency)
    hitboxTransparencyValueLabel.Parent = hitboxExpanderContainer

    -- Обработчики событий для Aimbot
    local smoothnessDragging = false
    smoothnessSliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            smoothnessDragging = true
        end
    end)
    smoothnessSliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            smoothnessDragging = false
        end
    end)

    local aimbotRadiusDragging = false
    radiusSliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            aimbotRadiusDragging = true
        end
    end)
    radiusSliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            aimbotRadiusDragging = false
        end
    end)

    local aimbotFovSizeDragging = false
    aimbotFovSizeSliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            aimbotFovSizeDragging = true
        end
    end)
    aimbotFovSizeSliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            aimbotFovSizeDragging = false
        end
    end)

    -- Обработчики событий для Silent Aim
    local silentFovSizeDragging = false
    silentFovSizeSliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            silentFovSizeDragging = true
        end
    end)
    silentFovSizeSliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            silentFovSizeDragging = false
        end
    end)

    -- Обработчики событий для Hitbox Expander
    local hitboxSizeDragging = false
    hitboxSizeSliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hitboxSizeDragging = true
        end
    end)
    hitboxSizeSliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hitboxSizeDragging = false
        end
    end)

    local hitboxTransparencyDragging = false
    hitboxTransparencySliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hitboxTransparencyDragging = true
        end
    end)
    hitboxTransparencySliderKnob.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hitboxTransparencyDragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if smoothnessDragging then
                local mouseX = input.Position.X
                local sliderX = smoothnessSliderFrame.AbsolutePosition.X
                local sliderWidth = smoothnessSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                AimbotState.Smoothness = math.floor(1 + (relativeX * (100 - 1)))
                smoothnessSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                smoothnessSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                smoothnessValueLabel.Text = tostring(AimbotState.Smoothness) .. "%"
            elseif aimbotRadiusDragging then
                local mouseX = input.Position.X
                local sliderX = radiusSliderFrame.AbsolutePosition.X
                local sliderWidth = radiusSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                AimbotState.Radius = math.floor(20 + (relativeX * (100 - 20)))
                radiusSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                radiusSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                radiusValueLabel.Text = tostring(AimbotState.Radius)
            elseif aimbotFovSizeDragging then
                local mouseX = input.Position.X
                local sliderX = aimbotFovSizeSliderFrame.AbsolutePosition.X
                local sliderWidth = aimbotFovSizeSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                AimbotState.FOVSize = math.floor(1 + (relativeX * (700 - 1)))
                aimbotFovSizeSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                aimbotFovSizeSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                aimbotFovSizeValueLabel.Text = tostring(AimbotState.FOVSize)
            elseif silentFovSizeDragging then
                local mouseX = input.Position.X
                local sliderX = silentFovSizeSliderFrame.AbsolutePosition.X
                local sliderWidth = silentFovSizeSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                SilentAimState.FOVSize = math.floor(1 + (relativeX * (700 - 1)))
                silentFovSizeSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                silentFovSizeSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                silentFovSizeValueLabel.Text = tostring(SilentAimState.FOVSize)
            elseif hitboxSizeDragging then
                local mouseX = input.Position.X
                local sliderX = hitboxSizeSliderFrame.AbsolutePosition.X
                local sliderWidth = hitboxSizeSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                HitboxExpanderState.Size = math.floor(1 + (relativeX * (8 - 1)))
                hitboxSizeSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                hitboxSizeSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                hitboxSizeValueLabel.Text = tostring(HitboxExpanderState.Size) .. " studs"
            elseif hitboxTransparencyDragging then
                local mouseX = input.Position.X
                local sliderX = hitboxTransparencySliderFrame.AbsolutePosition.X
                local sliderWidth = hitboxTransparencySliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                HitboxExpanderState.Transparency = math.floor(relativeX * 100) / 100 -- Округление до 2 знаков
                hitboxTransparencySliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                hitboxTransparencySliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                hitboxTransparencyValueLabel.Text = tostring(HitboxExpanderState.Transparency)
            end
        end
    end)

    -- Переключение типа бинда (Aimbot)
    bindTypeToggle.MouseButton1Click:Connect(function()
        AimbotState.BindType = AimbotState.BindType == "Mouse" and "Key" or "Mouse"
        bindTypeToggle.Text = "Bind: " .. AimbotState.BindType
        bindSelectButton.Text = AimbotState.BindType == "Mouse" and "RMB" or AimbotState.KeyBind.Name
    end)

    -- Выбор бинда (Aimbot)
    local waitingForBind = false
    bindSelectButton.MouseButton1Click:Connect(function()
        if waitingForBind then return end
        waitingForBind = true
        bindSelectButton.Text = "Press a key/mouse..."
        
        local connection
        connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if AimbotState.BindType == "Mouse" and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 or input.UserInputType == Enum.UserInputType.MouseButton3) then
                AimbotState.MouseBind = input.UserInputType
                bindSelectButton.Text = input.UserInputType == Enum.UserInputType.MouseButton1 and "LMB" or input.UserInputType == Enum.UserInputType.MouseButton2 and "RMB" or "MMB"
            elseif AimbotState.BindType == "Key" and input.KeyCode ~= Enum.KeyCode.Unknown then
                AimbotState.KeyBind = input.KeyCode
                bindSelectButton.Text = input.KeyCode.Name
            end
            waitingForBind = false
            connection:Disconnect()
        end)
    end)

    -- Переключение части тела (Aimbot)
    aimbotTargetPartToggle.MouseButton1Click:Connect(function()
        AimbotState.TargetPart = AimbotState.TargetPart == "Head" and "Body" or "Head"
        aimbotTargetPartToggle.Text = "Target: " .. AimbotState.TargetPart
    end)

    -- Обработчики тогглов (Aimbot)
    aimbotToggle.MouseButton1Click:Connect(function()
        AimbotState.Enabled = not AimbotState.Enabled
        aimbotToggle.Text = "Aimbot: " .. (AimbotState.Enabled and "ON" or "OFF")
    end)

    skipWallToggle.MouseButton1Click:Connect(function()
        AimbotState.SkipWall = not AimbotState.SkipWall
        skipWallToggle.Text = "Skip Wall: " .. (AimbotState.SkipWall and "ON" or "OFF")
    end)

    aimbotFovToggle.MouseButton1Click:Connect(function()
        AimbotState.FOVEnabled = not AimbotState.FOVEnabled
        aimbotFovToggle.Text = "FOV: " .. (AimbotState.FOVEnabled and "ON" or "OFF")
    end)

    aimbotSnaplineToggle.MouseButton1Click:Connect(function()
        AimbotState.SnaplineEnabled = not AimbotState.SnaplineEnabled
        aimbotSnaplineToggle.Text = "Snapline: " .. (AimbotState.SnaplineEnabled and "ON" or "OFF")
    end)

    -- Обработчики тогглов (Silent Aim)
    silentAimToggle.MouseButton1Click:Connect(function()
        SilentAimState.Enabled = not SilentAimState.Enabled
        silentAimToggle.Text = "Silent Aim: " .. (SilentAimState.Enabled and "ON" or "OFF")
    end)

    silentFovToggle.MouseButton1Click:Connect(function()
        SilentAimState.FOVEnabled = not SilentAimState.FOVEnabled
        silentFovToggle.Text = "FOV: " .. (SilentAimState.FOVEnabled and "ON" or "OFF")
    end)

    silentSnaplineToggle.MouseButton1Click:Connect(function()
        SilentAimState.SnaplineEnabled = not SilentAimState.SnaplineEnabled
        silentSnaplineToggle.Text = "Snapline: " .. (SilentAimState.SnaplineEnabled and "ON" or "OFF")
    end)

    silentTargetPartToggle.MouseButton1Click:Connect(function()
        SilentAimState.TargetPart = SilentAimState.TargetPart == "Head" and "Body" or "Head"
        silentTargetPartToggle.Text = "Target: " .. SilentAimState.TargetPart
    end)

    -- Обработчики тогглов (Hitbox Expander)
    hitboxExpanderToggle.MouseButton1Click:Connect(function()
        HitboxExpanderState.Enabled = not HitboxExpanderState.Enabled
        hitboxExpanderToggle.Text = "Hitbox Expander: " .. (HitboxExpanderState.Enabled and "ON" or "OFF")
    end)
end

    if category == "Misc" then
        -- Speed Hack Container
        local speedContainer = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.Container) do
            speedContainer[prop] = value
        end
        speedContainer.Position = UDim2.new(0, 0, 0, 0)
        speedContainer.Parent = frame

        local speedLabel = Instance.new("TextLabel")
        for prop, value in pairs(LayoutSettings.ContainerLabel) do
            speedLabel[prop] = value
        end
        speedLabel.Text = "Speed Hack"
        speedLabel.Parent = speedContainer

        local speedToggle = Instance.new("TextButton")
        for prop, value in pairs(LayoutSettings.ToggleButton) do
            speedToggle[prop] = value
        end
        speedToggle.Position = UDim2.new(0, 5, 0, 25)
        speedToggle.Text = "Speed: OFF"
        speedToggle.Parent = speedContainer

        local speedSliderFrame = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderFrame) do
            speedSliderFrame[prop] = value
        end
        speedSliderFrame.Position = UDim2.new(0, 110, 0, 25)
        speedSliderFrame.Parent = speedContainer

        local speedSliderBar = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderBar) do
            speedSliderBar[prop] = value
        end
        speedSliderBar.Parent = speedSliderFrame

        local speedSliderKnob = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderKnob) do
            speedSliderKnob[prop] = value
        end
        speedSliderKnob.Position = UDim2.new(0, 0, 0, 0)
        speedSliderKnob.Parent = speedSliderFrame

        local speedValueLabel = Instance.new("TextLabel")
        speedValueLabel.Size = UDim2.new(0, 50, 0, 20)
        speedValueLabel.Position = UDim2.new(0, 265, 0, 25)
        speedValueLabel.BackgroundTransparency = 1
        speedValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        speedValueLabel.TextScaled = true
        speedValueLabel.Text = tostring(SpeedState.Value)
        speedValueLabel.Parent = speedContainer

        local speedDragging = false
        speedSliderKnob.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                speedDragging = true
            end
        end)

        speedSliderKnob.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                speedDragging = false
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if speedDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local mouseX = input.Position.X
                local sliderX = speedSliderFrame.AbsolutePosition.X
                local sliderWidth = speedSliderFrame.AbsoluteSize.X
                local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                
                SpeedState.Value = math.floor(20 + (relativeX * (60 - 20)))
                speedSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                speedSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                speedValueLabel.Text = tostring(SpeedState.Value)
                
                if SpeedState.Enabled then
                    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
                    if humanoid then
                        humanoid.WalkSpeed = SpeedState.Value
                    end
                end
            end
        end)

        speedToggle.MouseButton1Click:Connect(function()
            SpeedState.Enabled = not SpeedState.Enabled
            speedToggle.Text = "Speed: " .. (SpeedState.Enabled and "ON" or "OFF")
            
            local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = SpeedState.Enabled and SpeedState.Value or SpeedState.DefaultSpeed
            end
        end)

        -- Fly Container
        local flyContainer = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.Container) do
            flyContainer[prop] = value
        end
        flyContainer.Position = UDim2.new(0, 0, 0, 110)
        flyContainer.Parent = frame

        local flyLabel = Instance.new("TextLabel")
        for prop, value in pairs(LayoutSettings.ContainerLabel) do
            flyLabel[prop] = value
        end
        flyLabel.Text = "Fly Hack"
        flyLabel.Parent = flyContainer

        local flyToggle = Instance.new("TextButton")
        for prop, value in pairs(LayoutSettings.ToggleButton) do
            flyToggle[prop] = value
        end
        flyToggle.Position = UDim2.new(0, 5, 0, 25)
        flyToggle.Text = "Fly: OFF"
        flyToggle.Parent = flyContainer

        local flyWalkSliderFrame = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderFrame) do
            flyWalkSliderFrame[prop] = value
        end
        flyWalkSliderFrame.Position = UDim2.new(0, 110, 0, 25)
        flyWalkSliderFrame.Parent = flyContainer

        local flyWalkSliderBar = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderBar) do
            flyWalkSliderBar[prop] = value
        end
        flyWalkSliderBar.Parent = flyWalkSliderFrame

        local flyWalkSliderKnob = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderKnob) do
            flyWalkSliderKnob[prop] = value
        end
        flyWalkSliderKnob.Position = UDim2.new(0, 0, 0, 0)
        flyWalkSliderKnob.Parent = flyWalkSliderFrame

        local flyWalkValueLabel = Instance.new("TextLabel")
        flyWalkValueLabel.Size = UDim2.new(0, 50, 0, 20)
        flyWalkValueLabel.Position = UDim2.new(0, 265, 0, 25)
        flyWalkValueLabel.BackgroundTransparency = 1
        flyWalkValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        flyWalkValueLabel.TextScaled = true
        flyWalkValueLabel.Text = tostring(FlyState.WalkSpeed)
        flyWalkValueLabel.Parent = flyContainer

        local flyVerticalSliderFrame = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderFrame) do
            flyVerticalSliderFrame[prop] = value
        end
        flyVerticalSliderFrame.Position = UDim2.new(0, 110, 0, 55)
        flyVerticalSliderFrame.Parent = flyContainer

        local flyVerticalSliderBar = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderBar) do
            flyVerticalSliderBar[prop] = value
        end
        flyVerticalSliderBar.Parent = flyVerticalSliderFrame

        local flyVerticalSliderKnob = Instance.new("Frame")
        for prop, value in pairs(LayoutSettings.SliderKnob) do
            flyVerticalSliderKnob[prop] = value
        end
        flyVerticalSliderKnob.Position = UDim2.new(0, 0, 0, 0)
        flyVerticalSliderKnob.Parent = flyVerticalSliderFrame

        local flyVerticalValueLabel = Instance.new("TextLabel")
        flyVerticalValueLabel.Size = UDim2.new(0, 50, 0, 20)
        flyVerticalValueLabel.Position = UDim2.new(0, 265, 0, 55)
        flyVerticalValueLabel.BackgroundTransparency = 1
        flyVerticalValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        flyVerticalValueLabel.TextScaled = true
        flyVerticalValueLabel.Text = tostring(FlyState.VerticalSpeed)
        flyVerticalValueLabel.Parent = flyContainer

        local flyModeToggle = Instance.new("TextButton")
        for prop, value in pairs(LayoutSettings.ToggleButton) do
            flyModeToggle[prop] = value
        end
        flyModeToggle.Position = UDim2.new(0, 5, 0, 55)
        flyModeToggle.Text = "Mode: " .. FlyState.Mode
        flyModeToggle.Parent = flyContainer

        local flyWalkDragging = false
        flyWalkSliderKnob.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                flyWalkDragging = true
            end
        end)

        flyWalkSliderKnob.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                flyWalkDragging = false
            end
        end)

        local flyVerticalDragging = false
        flyVerticalSliderKnob.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                flyVerticalDragging = true
            end
        end)

        flyVerticalSliderKnob.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                flyVerticalDragging = false
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                if flyWalkDragging then
                    local mouseX = input.Position.X
                    local sliderX = flyWalkSliderFrame.AbsolutePosition.X
                    local sliderWidth = flyWalkSliderFrame.AbsoluteSize.X
                    local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                    
                    FlyState.WalkSpeed = math.floor(20 + (relativeX * (60 - 20)))
                    flyWalkSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                    flyWalkSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                    flyWalkValueLabel.Text = tostring(FlyState.WalkSpeed)
                end
                if flyVerticalDragging then
                    local mouseX = input.Position.X
                    local sliderX = flyVerticalSliderFrame.AbsolutePosition.X
                    local sliderWidth = flyVerticalSliderFrame.AbsoluteSize.X
                    local relativeX = math.clamp((mouseX - sliderX) / sliderWidth, 0, 1)
                    
                    FlyState.VerticalSpeed = math.floor(20 + (relativeX * (100 - 20)))
                    flyVerticalSliderKnob.Position = UDim2.new(relativeX, -5, 0, 0)
                    flyVerticalSliderBar.Size = UDim2.new(relativeX, 0, 1, 0)
                    flyVerticalValueLabel.Text = tostring(FlyState.VerticalSpeed)
                end
            end
        end)

        flyModeToggle.MouseButton1Click:Connect(function()
            FlyState.Mode = FlyState.Mode == "FreeFly" and "Platform" or "FreeFly"
            flyModeToggle.Text = "Mode: " .. FlyState.Mode
        end)

        flyToggle.MouseButton1Click:Connect(function()
            FlyState.Enabled = not FlyState.Enabled
            flyToggle.Text = "Fly: " .. (FlyState.Enabled and "ON" or "OFF")
        end)

        LocalPlayer.CharacterAdded:Connect(function(character)
            local humanoid = character:WaitForChild("Humanoid", 5)
            local rootPart = character:WaitForChild("HumanoidRootPart", 5)
            if not humanoid or not rootPart then return end
            
            if SpeedState.Enabled then
                humanoid.WalkSpeed = SpeedState.Value
            end
        end)
    end

    button.MouseButton1Click:Connect(function()
        if CategoryState.SelectedCategory and GuiElements.CategoryButtons[CategoryState.SelectedCategory] then
            GuiElements.CategoryButtons[CategoryState.SelectedCategory].BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        end
        button.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
        CategoryState.SelectedCategory = category
        for cat, frm in pairs(GuiElements.CategoryFrames) do
            frm.Visible = (cat == category)
        end
    end)
end

-- Создание кнопки Unhook
GuiElements.UnhookButton = Instance.new("TextButton")
for prop, value in pairs(LayoutSettings.UnhookButton) do
    GuiElements.UnhookButton[prop] = value
end
GuiElements.UnhookButton.Parent = GuiElements.MainFrame

GuiElements.UnhookButton.MouseButton1Click:Connect(function()
    GuiElements.ScreenGui:Destroy()
    for k, v in pairs(GuiElements) do GuiElements[k] = nil end
    for k, v in pairs(LayoutSettings) do LayoutSettings[k] = nil end
    for k, v in pairs(CategoryState) do CategoryState[k] = nil end
    for k, v in pairs(ESPState) do ESPState[k] = nil end
    for k, v in pairs(SpeedState) do SpeedState[k] = nil end
    for k, v in pairs(FlyState) do FlyState[k] = nil end
    UserInputService.InputBegan:Disconnect()
    UserInputService.InputChanged:Disconnect()
end)

-- Логика Fly
local function updateFly()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end

    if FlyState.Enabled then
        humanoid.PlatformStand = true
        rootPart.Velocity = Vector3.new(0, 0, 0)

        if FlyState.Mode == "FreeFly" then
            local moveDirection = Vector3.new()
            local camera = workspace.CurrentCamera
            local lookVector = camera.CFrame.LookVector
            local rightVector = camera.CFrame.RightVector

            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection = moveDirection + lookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection = moveDirection - lookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection = moveDirection + rightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection = moveDirection - rightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection = moveDirection + Vector3.new(0, 1, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection = moveDirection - Vector3.new(0, 1, 0)
            end

            if moveDirection.Magnitude > 0 then
                moveDirection = moveDirection.Unit
                rootPart.Velocity = Vector3.new(
                    moveDirection.X * FlyState.WalkSpeed,
                    moveDirection.Y * FlyState.VerticalSpeed,
                    moveDirection.Z * FlyState.WalkSpeed
                )
            end
        elseif FlyState.Mode == "Platform" then
            local spacePressed = false
            UserInputService.InputBegan:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.Space and FlyState.Enabled then
                    spacePressed = true
                    FlyState.PlatformActive = true
                    rootPart.Velocity = Vector3.new(0, FlyState.VerticalSpeed, 0)
                    task.wait(0.5)
                    if FlyState.Enabled and FlyState.Mode == "Platform" then
                        rootPart.Velocity = Vector3.new(0, 0, 0)
                    end
                end
            end)

            UserInputService.InputEnded:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.Space then
                    spacePressed = false
                end
            end)

            if FlyState.PlatformActive and not spacePressed then
                rootPart.Velocity = Vector3.new(0, 0, 0)
            end
        end
    else
        humanoid.PlatformStand = false
        FlyState.PlatformActive = false
    end
end

-- Логика ESP для игроков (без изменений)
local ESP = {}
local camera = workspace.CurrentCamera or workspace:WaitForChild("CurrentCamera")

local weaponList = {"Ak1", "C4", "Revolver", "Rocket Launcher", "Bow"}

local function getPlayerWeapon(character)
    if not character then return "None" end
    for _, tool in pairs(character:GetChildren()) do
        if tool:IsA("Tool") then
            for _, weapon in pairs(weaponList) do
                if tool.Name == weapon then
                    return weapon
                end
            end
        end
    end
    return "None"
end

local function createESP(player)
    if player == LocalPlayer then return end
    
    local function setupESP()
        local character = player.Character
        if not character then return end
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 5)
        local humanoid = character:WaitForChild("Humanoid", 5)
        if not humanoidRootPart or not humanoid then return end

        if ESP[player] then
            if ESP[player].Box then ESP[player].Box:Remove() end
            if ESP[player].Text then ESP[player].Text:Remove() end
            ESP[player] = nil
        end

        local box = Drawing.new("Square")
        box.Thickness = 2
        box.Filled = false
        box.Color = ESPState.Color
        box.Visible = false

        local text = Drawing.new("Text")
        text.Size = 16
        text.Color = Color3.fromRGB(255, 255, 255)
        text.Visible = false

        ESP[player] = {Box = box, Text = text}

        local connection
        connection = RunService.RenderStepped:Connect(function()
            if not player.Character or not player.Character.Parent or not humanoidRootPart or not humanoid or humanoid.Health <= 0 then
                box.Visible = false
                text.Visible = false
                if connection then
                    connection:Disconnect()
                end
                if ESP[player] then
                    if ESP[player].Box then ESP[player].Box:Remove() end
                    if ESP[player].Text then ESP[player].Text:Remove() end
                    ESP[player] = nil
                end
                return
            end

            if ESPState.Enabled then
                local rootPos, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    local size = character:GetExtentsSize() * 1.2
                    local topLeft = camera:WorldToViewportPoint(humanoidRootPart.Position + Vector3.new(size.X/2, size.Y/2, size.Z/2))
                    local bottomRight = camera:WorldToViewportPoint(humanoidRootPart.Position - Vector3.new(size.X/2, size.Y/2, size.Z/2))

                    if topLeft.Z > 0 and bottomRight.Z > 0 then
                        local width = math.abs(topLeft.X - bottomRight.X)
                        local height = math.abs(topLeft.Y - bottomRight.Y)
                        local centerX = (topLeft.X + bottomRight.X) / 2

                        box.Size = Vector2.new(width, height)
                        box.Position = Vector2.new(centerX - width / 2, topLeft.Y)
                        box.Color = ESPState.Color
                        box.Visible = true

                        local textString = ""
                        if ESPState.Name then
                            textString = textString .. player.Name .. "\n"
                        end
                        if ESPState.Studs then
                            local distance = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (humanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude) or 0
                            textString = textString .. math.floor(distance) .. " studs\n"
                        end
                        if ESPState.HP then
                            textString = textString .. math.floor(humanoid.Health) .. "/" .. humanoid.MaxHealth .. " HP\n"
                        end
                        if ESPState.WeaponEnabled then
                            local weapon = getPlayerWeapon(character)
                            textString = textString .. weapon
                        end

                        text.Text = textString
                        text.Position = Vector2.new(centerX - width / 2, topLeft.Y - 20)
                        text.Visible = textString ~= ""
                    else
                        box.Visible = false
                        text.Visible = false
                    end
                else
                    box.Visible = false
                    text.Visible = false
                end
            else
                box.Visible = false
                text.Visible = false
            end
        end)
    end

    if player.Character then
        spawn(function()
            pcall(setupESP)
        end)
    end

    player.CharacterAdded:Connect(function()
        spawn(function()
            pcall(setupESP)
        end)
    end)
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        spawn(function()
            pcall(createESP, player)
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        spawn(function()
            pcall(createESP, player)
        end)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if ESP[player] then
        if ESP[player].Box then ESP[player].Box:Remove() end
        if ESP[player].Text then ESP[player].Text:Remove() end
        ESP[player] = nil
    end
end)

-- Логика Object ESP
local ObjectESP = {}
local trackedObjects = {}
local newObjectTimes = {}

local function getDistanceToPlayer(obj)
    local playerRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not playerRoot then return math.huge end
    local objRoot = obj:IsA("Model") and obj.PrimaryPart or obj
    if not objRoot then return math.huge end
    return (playerRoot.Position - objRoot.Position).Magnitude
end

local function createObjectESP(object)
    if ObjectESP[object] then return end

    local box = Drawing.new("Square")
    box.Thickness = 2
    box.Filled = false
    box.Color = ObjectESPState.Color
    box.Visible = false

    local text = Drawing.new("Text")
    text.Size = 16
    text.Color = Color3.fromRGB(255, 255, 255)
    text.Visible = false

    ObjectESP[object] = {Box = box, Text = text}
    table.insert(trackedObjects, object)
    newObjectTimes[object] = tick()

    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not object.Parent or not ObjectESPState.Enabled or not ObjectESPState.SelectedObjects[object.Name] then
            box.Visible = false
            text.Visible = false
            if connection then
                connection:Disconnect()
            end
            if ObjectESP[object] then
                if ObjectESP[object].Box then ObjectESP[object].Box:Remove() end
                if ObjectESP[object].Text then ObjectESP[object].Text:Remove() end
                ObjectESP[object] = nil
                for i, trackedObj in ipairs(trackedObjects) do
                    if trackedObj == object then
                        table.remove(trackedObjects, i)
                        break
                    end
                end
                newObjectTimes[object] = nil
            end
            return
        end

        local rootPart = object:IsA("Model") and object.PrimaryPart or object
        if not rootPart then return end

        local rootPos, onScreen = camera:WorldToViewportPoint(rootPart.Position)
        if onScreen then
            local size = (object:IsA("Model") and object:GetExtentsSize() or rootPart.Size) * 1.2
            local topLeft = camera:WorldToViewportPoint(rootPart.Position + Vector3.new(size.X/2, size.Y/2, size.Z/2))
            local bottomRight = camera:WorldToViewportPoint(rootPart.Position - Vector3.new(size.X/2, size.Y/2, size.Z/2))

            if topLeft.Z > 0 and bottomRight.Z > 0 then
                local width = math.abs(topLeft.X - bottomRight.X)
                local height = math.abs(topLeft.Y - bottomRight.Y)
                local centerX = (topLeft.X + bottomRight.X) / 2

                box.Size = Vector2.new(width, height)
                box.Position = Vector2.new(centerX - width / 2, topLeft.Y)

                if newObjectTimes[object] and (tick() - newObjectTimes[object]) < ObjectESPState.NewObjectDuration then
                    box.Color = ObjectESPState.NewObjectColor
                else
                    box.Color = ObjectESPState.Color
                end
                box.Visible = true

                text.Text = object.Name
                text.Position = Vector2.new(centerX - width / 2, topLeft.Y - 20)
                text.Visible = true
            else
                box.Visible = false
                text.Visible = false
            end
        else
            box.Visible = false
            text.Visible = false
        end
    end)
end

local function updateObjectESP()
    if not ObjectESPState.Enabled then
        for _, obj in pairs(ObjectESP) do
            if obj.Box then obj.Box:Remove() end
            if obj.Text then obj.Text:Remove() end
        end
        ObjectESP = {}
        trackedObjects = {}
        newObjectTimes = {}
        return
    end

    -- Собираем все подходящие объекты
    local allObjects = {}
    for _, objName in pairs({"Crate", "MilitaryCrate", "Helicopter", "Recycler"}) do
        if ObjectESPState.SelectedObjects[objName] then
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj.Name == objName then
                    table.insert(allObjects, obj)
                end
            end
        end
    end

    -- Сортируем по расстоянию до игрока
    table.sort(allObjects, function(a, b)
        return getDistanceToPlayer(a) < getDistanceToPlayer(b)
    end)

    -- Очищаем старые объекты, которые больше не в топ-15
    for obj, esp in pairs(ObjectESP) do
        local isInTop15 = false
        for i = 1, math.min(#allObjects, ObjectESPState.MaxObjects) do
            if allObjects[i] == obj then
                isInTop15 = true
                break
            end
        end
        if not isInTop15 then
            if esp.Box then esp.Box:Remove() end
            if esp.Text then esp.Text:Remove() end
            ObjectESP[obj] = nil
            for i, trackedObj in ipairs(trackedObjects) do
                if trackedObj == obj then
                    table.remove(trackedObjects, i)
                    break
                end
            end
            newObjectTimes[obj] = nil
        end
    end

    -- Добавляем новые объекты из топ-15
    for i = 1, math.min(#allObjects, ObjectESPState.MaxObjects) do
        local obj = allObjects[i]
        if not ObjectESP[obj] then
            createObjectESP(obj)
        end
    end
end

-- Запускаем проверку каждую секунду
task.spawn(function()
    while true do
        if ObjectESPState.Enabled then
            updateObjectESP()
        end
        wait(1) -- Проверка каждую секунду
    end
end)

workspace.DescendantAdded:Connect(function(obj)
    if ObjectESPState.Enabled and ObjectESPState.SelectedObjects[obj.Name] then
        -- Немедленная проверка при добавлении нового объекта
        updateObjectESP()
    end
end)

-- Логика Aimbot
local aimbotSnapline = Drawing.new("Line")
aimbotSnapline.Thickness = 2
aimbotSnapline.Color = Color3.fromRGB(255, 0, 0)
aimbotSnapline.Visible = false

local aimbotFovCircle = Drawing.new("Circle")
aimbotFovCircle.Thickness = 1
aimbotFovCircle.NumSides = 64
aimbotFovCircle.Radius = AimbotState.FOVSize
aimbotFovCircle.Color = Color3.fromRGB(0, 255, 0)
aimbotFovCircle.Filled = false
aimbotFovCircle.Visible = false

local silentSnapline = Drawing.new("Line")
silentSnapline.Thickness = 2
silentSnapline.Color = Color3.fromRGB(0, 255, 255)
silentSnapline.Visible = false

local silentFovCircle = Drawing.new("Circle")
silentFovCircle.Thickness = 1
silentFovCircle.NumSides = 64
silentFovCircle.Radius = SilentAimState.FOVSize
silentFovCircle.Color = Color3.fromRGB(255, 255, 0)
silentFovCircle.Filled = false
silentFovCircle.Visible = false

local aimbotActive = false
local silentAimActive = false
local teleportedPlayer = nil
local originalHitboxData = {}
local defaultFOV = 70

-- Переменные для Titles
local titles = {}
local menuVisible = false
local rgbTime = 0

-- Переменные для Staff Online
local staffFrame = nil
local staffLabels = {}
local dragging = false
local dragOffset = Vector2.new(0, 0)

-- Функции для Aimbot
local function isInAimbotFOV(targetPos)
    if not AimbotState.FOVEnabled then return true end
    local mousePos = UserInputService:GetMouseLocation()
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
    return distance <= AimbotState.FOVSize
end

local function canSeeTarget(startPos, targetPos)
    if not AimbotState.SkipWall then return true end
    local ray = Ray.new(startPos, (targetPos - startPos).Unit * (targetPos - startPos).Magnitude)
    local hit = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
    return hit == nil or hit:IsDescendantOf(targetPos.Parent)
end

local function getAimbotTarget()
    local nearestTarget = nil
    local nearestDistance = AimbotState.FOVEnabled and math.huge or AimbotState.Radius
    local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            local targetPart = AimbotState.TargetPart == "Head" and player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and humanoid.Health > 0 and (not AimbotState.FOVEnabled or isInAimbotFOV(targetPart.Position)) then
                local distance = (rootPart.Position - targetPart.Position).Magnitude
                if (AimbotState.FOVEnabled and distance < nearestDistance) or (not AimbotState.FOVEnabled and distance <= AimbotState.Radius) then
                    if canSeeTarget(rootPart.Position, targetPart.Position) then
                        nearestDistance = distance
                        nearestTarget = targetPart
                    end
                end
            end
        end
    end
    return nearestTarget
end

local function updateAimbot()
    if not AimbotState.Enabled then
        aimbotSnapline.Visible = false
        aimbotFovCircle.Visible = false
        return
    end

    if AimbotState.BindType == "Mouse" then
        aimbotActive = UserInputService:IsMouseButtonPressed(AimbotState.MouseBind)
    elseif AimbotState.BindType == "Key" then
        aimbotActive = UserInputService:IsKeyDown(AimbotState.KeyBind)
    end

    local target = getAimbotTarget()

    if AimbotState.SnaplineEnabled and target then
        local screenPos, onScreen = camera:WorldToViewportPoint(target.Position)
        if onScreen then
            aimbotSnapline.From = UserInputService:GetMouseLocation()
            aimbotSnapline.To = Vector2.new(screenPos.X, screenPos.Y)
            aimbotSnapline.Visible = true
        else
            aimbotSnapline.Visible = false
        end
    else
        aimbotSnapline.Visible = false
    end

    if aimbotActive and target then
        local targetPosition = target.Position
        local cameraPosition = camera.CFrame.Position
        local direction = (targetPosition - cameraPosition).Unit
        local newCFrame = CFrame.new(cameraPosition, cameraPosition + direction)
        local lerpFactor = AimbotState.Smoothness / 100
        camera.CFrame = camera.CFrame:Lerp(newCFrame, lerpFactor)
    end

    local mousePos = UserInputService:GetMouseLocation()
    aimbotFovCircle.Position = mousePos
    aimbotFovCircle.Radius = AimbotState.FOVSize
    aimbotFovCircle.Visible = AimbotState.FOVEnabled
end

-- Функции для Silent Aim
local function isInSilentFOV(targetPos)
    if not SilentAimState.FOVEnabled then return true end
    local mousePos = UserInputService:GetMouseLocation()
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
    return distance <= SilentAimState.FOVSize
end

local function getSilentTarget()
    local nearestTarget = nil
    local nearestDistance = math.huge
    local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            local targetPart = SilentAimState.TargetPart == "Head" and player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and humanoid.Health > 0 and isInSilentFOV(targetPart.Position) then
                local distance = (rootPart.Position - targetPart.Position).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestTarget = { Player = player, Part = targetPart }
                end
            end
        end
    end
    return nearestTarget
end

local function updateSilentAim()
    if not SilentAimState.Enabled then
        silentSnapline.Visible = false
        silentFovCircle.Visible = false
        if teleportedPlayer then
            local rootPart = teleportedPlayer.Player.Character and teleportedPlayer.Player.Character:FindFirstChild("HumanoidRootPart")
            if rootPart and teleportedPlayer.OriginalCFrame then
                rootPart.CFrame = teleportedPlayer.OriginalCFrame
            end
            teleportedPlayer = nil
        end
        return
    end

    local target = getSilentTarget()
    local wasActive = silentAimActive
    silentAimActive = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)

    if SilentAimState.SnaplineEnabled and target then
        local screenPos, onScreen = camera:WorldToViewportPoint(target.Part.Position)
        if onScreen then
            silentSnapline.From = UserInputService:GetMouseLocation()
            silentSnapline.To = Vector2.new(screenPos.X, screenPos.Y)
            silentSnapline.Visible = true
        else
            silentSnapline.Visible = false
        end
    else
        silentSnapline.Visible = false
    end

    local mousePos = UserInputService:GetMouseLocation()
    silentFovCircle.Position = mousePos
    silentFovCircle.Radius = SilentAimState.FOVSize
    silentFovCircle.Visible = SilentAimState.FOVEnabled

    if silentAimActive and target then
        local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            if not teleportedPlayer or teleportedPlayer.Player ~= target.Player then
                teleportedPlayer = {
                    Player = target.Player,
                    Part = target.Part,
                    OriginalCFrame = target.Player.Character.HumanoidRootPart.CFrame
                }
            end

            local mouseRay = camera:ViewportPointToRay(mousePos.X, mousePos.Y)
            local targetPosition = mouseRay.Origin + mouseRay.Direction * 20
            local offset = target.Part.Position - target.Player.Character.HumanoidRootPart.Position
            target.Player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition - offset)
        end
    elseif wasActive and not silentAimActive and teleportedPlayer then
        local rootPart = teleportedPlayer.Player.Character and teleportedPlayer.Player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart and teleportedPlayer.OriginalCFrame then
            rootPart.CFrame = teleportedPlayer.OriginalCFrame
        end
        teleportedPlayer = nil
    end
end

-- Функции для Hitbox Expander
local function updateHitboxExpander()
    if not HitboxExpanderState.Enabled then
        for player, data in pairs(originalHitboxData) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = player.Character.HumanoidRootPart
                rootPart.Size = data.Size
                rootPart.Transparency = data.Transparency
            end
        end
        originalHitboxData = {}
        return
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            if not originalHitboxData[player] then
                originalHitboxData[player] = {
                    Size = rootPart.Size,
                    Transparency = rootPart.Transparency
                }
            end
            rootPart.Size = Vector3.new(HitboxExpanderState.Size, HitboxExpanderState.Size, HitboxExpanderState.Size)
            rootPart.Transparency = HitboxExpanderState.Transparency
        end
    end
end

-- Функции для View Model
local function updateViewModel()
    if ViewModelState.Enabled then
        camera.FieldOfView = ViewModelState.FOV
    else
        camera.FieldOfView = defaultFOV
    end
end

-- Функции для Titles
local function createTitle()
    local title = Drawing.new("Text")
    title.Text = "simfoniaHUB"
    title.Color = Color3.fromRGB(255, 255, 255)
    title.Size = math.random(20, 40)
    title.Position = Vector2.new(math.random(0, camera.ViewportSize.X), math.random(0, camera.ViewportSize.Y))
    title.Transparency = 0.7
    title.Visible = false

    local velocity = Vector2.new(math.random(-50, 50) / 10, math.random(-50, 50) / 10)
    return { Object = title, Velocity = velocity }
end

local function updateTitles(deltaTime)
    if not TitlesState.Enabled or not menuVisible then
        for _, title in pairs(titles) do
            title.Object.Visible = false
        end
        return
    end

    while #titles < 10 do
        table.insert(titles, createTitle())
    end

    if TitlesState.RGBEnabled then
        rgbTime = rgbTime + deltaTime
        local r = math.sin(rgbTime * 2) * 127 + 128
        local g = math.sin(rgbTime * 2 + 2) * 127 + 128
        local b = math.sin(rgbTime * 2 + 4) * 127 + 128
        local rgbColor = Color3.fromRGB(r, g, b)

        for _, title in pairs(titles) do
            title.Object.Color = rgbColor
        end
    else
        for _, title in pairs(titles) do
            title.Object.Color = Color3.fromRGB(255, 255, 255)
        end
    end

    for _, title in pairs(titles) do
        title.Object.Visible = true
        local newPos = title.Object.Position + title.Velocity
        local screenWidth = camera.ViewportSize.X
        local screenHeight = camera.ViewportSize.Y

        if newPos.X < 0 or newPos.X > screenWidth then
            title.Velocity = Vector2.new(-title.Velocity.X, title.Velocity.Y)
            newPos = Vector2.new(math.clamp(newPos.X, 0, screenWidth), newPos.Y)
        end
        if newPos.Y < 0 or newPos.Y > screenHeight then
            title.Velocity = Vector2.new(title.Velocity.X, -title.Velocity.Y)
            newPos = Vector2.new(newPos.X, math.clamp(newPos.Y, 0, screenHeight))
        end

        title.Object.Position = newPos
    end
end

-- Функции для Staff Online
local function createStaffMenu()
    if staffFrame then return end

    staffFrame = Instance.new("Frame")
    staffFrame.Size = UDim2.new(0, 100, 0, 300)
    staffFrame.Position = UDim2.new(0, 50, 0, 50)
    staffFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    staffFrame.BorderSizePixel = 0
    staffFrame.Parent = GuiElements.ScreenGui

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 20)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "Staff Online"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextScaled = true
    titleLabel.Parent = staffFrame

    for i, name in pairs(StaffOnlineState.Whitelist) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 20)
        label.Position = UDim2.new(0, 0, 0, 20 + (i - 1) * 20)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextScaled = true
        label.Parent = staffFrame
        staffLabels[name] = label
    end

    -- Логика перетаскивания
    staffFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragOffset = Vector2.new(input.Position.X - staffFrame.Position.X.Offset, input.Position.Y - staffFrame.Position.Y.Offset)
        end
    end)

    staffFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            staffFrame.Position = UDim2.new(0, input.Position.X - dragOffset.X, 0, input.Position.Y - dragOffset.Y)
        end
    end)
end

local function updateStaffMenu()
    if not StaffOnlineState.Enabled then
        if staffFrame then
            staffFrame.Visible = false
        end
        return
    end

    if not staffFrame then
        createStaffMenu()
    end

    staffFrame.Visible = true

    local currentPlayers = {}
    for _, player in pairs(Players:GetPlayers()) do
        currentPlayers[player.Name] = true
    end

    for name, label in pairs(staffLabels) do
        if currentPlayers[name] then
            label.TextColor3 = Color3.fromRGB(0, 255, 0)
        else
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
    end
end

RunService.RenderStepped:Connect(function(deltaTime)
    updateFly()
    updateAimbot()
    updateSilentAim()
    updateHitboxExpander()
    updateViewModel()
    updateTitles(deltaTime)
    updateStaffMenu()
end)

-- Обработка новых игроков для Hitbox Expander
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if HitboxExpanderState.Enabled then
            local rootPart = character:WaitForChild("HumanoidRootPart")
            if not originalHitboxData[player] then
                originalHitboxData[player] = {
                    Size = rootPart.Size,
                    Transparency = rootPart.Transparency
                }
            end
            rootPart.Size = Vector3.new(HitboxExpanderState.Size, HitboxExpanderState.Size, HitboxExpanderState.Size)
            rootPart.Transparency = HitboxExpanderState.Transparency
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    originalHitboxData[player] = nil
end)

-- Логика появления/скрытия меню
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        GuiElements.MainFrame.Visible = not GuiElements.MainFrame.Visible
        menuVisible = GuiElements.MainFrame.Visible
    end
end)
